---
- name: Ensure packaging variables provided
  assert:
    that:
      - install_service_release_version | length > 0
      - install_service_install_prefix | length > 0
      - install_service_asset_name | length > 0
      - install_service_archive_ext | length > 0
    fail_msg: install_service_release_version, install_service_install_prefix, install_service_asset_name, and install_service_archive_ext are required

- name: Set staging paths
  set_fact:
    install_service_release_dir: "{{ install_service_remote_staging_root }}/{{ install_service_release_version }}"
    install_service_package_tmp: "{{ install_service_remote_staging_root }}/.tmp/{{ install_service_asset_name }}"
    install_service_archive_path: "{{ install_service_remote_staging_root }}/{{ install_service_release_version }}/{{ install_service_asset_name }}{{ install_service_archive_ext }}"

- name: Ensure staging directories exist
  file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - "{{ install_service_release_dir }}"
    - "{{ install_service_package_tmp }}"

- name: Locate installed binary
  shell: |
    set -eu
    expected="{{ install_service_release_version }}"
    asset_name="{{ install_service_asset_name }}"
    is_musl=0
    case "$asset_name" in
      *musl*) is_musl=1 ;;
    esac

    get_ver() {
      candidate="$1"
      v=$("$candidate" --version 2>/dev/null | head -n1 | tr -d '\r' || true)
      if [ -z "$v" ] && [ "$is_musl" = "1" ] && command -v docker >/dev/null 2>&1; then
        cand_dir=$(dirname "$candidate")
        cand_base=$(basename "$candidate")
        v=$(docker run --rm -v "$cand_dir:/staged:ro" alpine:3.19 sh -lc "/staged/$cand_base --version 2>/dev/null | head -n1 | tr -d '\\r'" 2>/dev/null || true)
      fi
      printf '%s' "$v"
    }

    first_found=""
    for candidate in \
      "{{ install_service_install_prefix }}/bin/{{ install_service_binary_basename }}" \
      "{{ install_service_install_prefix }}/bin/cert_ctrl" \
      "{{ install_service_install_prefix }}/{{ install_service_binary_basename }}" \
      "{{ install_service_install_prefix }}/cert_ctrl"; do
      if [ -f "$candidate" ]; then
        if [ -z "$first_found" ]; then
          first_found="$candidate"
        fi
        # Prefer the candidate whose embedded version matches the release.
        actual=$(get_ver "$candidate")
        if [ -n "$actual" ] && [ "$actual" = "$expected" ]; then
          echo "$candidate"
          exit 0
        fi
      fi
    done
    if [ -n "$first_found" ]; then
      echo "$first_found"
      exit 0
    fi
    exit 1
  register: install_service_binary_path
  changed_when: false

- name: Stage binary for packaging
  copy:
    src: "{{ install_service_binary_path.stdout }}"
    dest: "{{ install_service_package_tmp }}/{{ install_service_binary_basename }}"
    mode: '0755'
    remote_src: true

- name: Verify staged binary version matches release version
  shell: |
    set -eu
    bin="{{ install_service_package_tmp }}/{{ install_service_binary_basename }}"
    expected="{{ install_service_release_version }}"
    asset_name="{{ install_service_asset_name }}"
    is_musl=0
    case "$asset_name" in
      *musl*) is_musl=1 ;;
    esac

    get_ver() {
      candidate="$1"
      v=$("$candidate" --version 2>/dev/null | head -n1 | tr -d '\r' || true)
      if [ -z "$v" ] && [ "$is_musl" = "1" ] && command -v docker >/dev/null 2>&1; then
        cand_dir=$(dirname "$candidate")
        cand_base=$(basename "$candidate")
        v=$(docker run --rm -v "$cand_dir:/staged:ro" alpine:3.19 sh -lc "/staged/$cand_base --version 2>/dev/null | head -n1 | tr -d '\\r'" 2>/dev/null || true)
      fi
      printf '%s' "$v"
    }

    actual=$(get_ver "$bin")
    if [ -z "$actual" ]; then
      echo "error: unable to execute staged binary for version check" >&2
      echo "debug: staged bin=$bin" >&2
      if command -v file >/dev/null 2>&1; then
        file "$bin" >&2 || true
      fi
      if [ "$is_musl" = "1" ]; then
        echo "debug: musl binary may not run on host; version check will run inside alpine container when docker is available." >&2
        if ! command -v docker >/dev/null 2>&1; then
          echo "debug: docker not found; cannot run musl version check." >&2
        fi
      fi
      exit 1
    fi

    if [ "$actual" != "$expected" ]; then
      # If multiple binaries exist in the install prefix (e.g. cert-ctrl vs
      # cert_ctrl), try to restage the one that matches the expected version.
      for candidate in \
        "{{ install_service_install_prefix }}/bin/{{ install_service_binary_basename }}" \
        "{{ install_service_install_prefix }}/bin/cert_ctrl" \
        "{{ install_service_install_prefix }}/{{ install_service_binary_basename }}" \
        "{{ install_service_install_prefix }}/cert_ctrl"; do
        if [ -x "$candidate" ]; then
          cand_ver=$(get_ver "$candidate")
          if [ -n "$cand_ver" ] && [ "$cand_ver" = "$expected" ]; then
            cp -f "$candidate" "$bin"
            chmod 0755 "$bin" || true
            actual=$(get_ver "$bin")
            break
          fi
        fi
      done
    fi

    if [ "$actual" != "$expected" ]; then
      echo "error: packaged binary version mismatch" >&2
      echo "  expected: $expected" >&2
      echo "  actual:   $actual" >&2

      echo "debug: install prefix={{ install_service_install_prefix }}" >&2
      echo "debug: staged bin=$bin" >&2
      echo "debug: candidate binaries and versions:" >&2
      for candidate in \
        "{{ install_service_install_prefix }}/bin/{{ install_service_binary_basename }}" \
        "{{ install_service_install_prefix }}/bin/cert_ctrl" \
        "{{ install_service_install_prefix }}/{{ install_service_binary_basename }}" \
        "{{ install_service_install_prefix }}/cert_ctrl"; do
        if [ -e "$candidate" ]; then
          ls -l "$candidate" >&2 || true
          v=$(get_ver "$candidate")
          echo "  $candidate -> ${v:-<no version output>}" >&2
        else
          echo "  $candidate -> <missing>" >&2
        fi
      done

      if [ -d "{{ install_service_repo_path | default('') }}" ]; then
        echo "debug: repo={{ install_service_repo_path }}" >&2
        (cd "{{ install_service_repo_path }}" && git rev-parse HEAD 2>/dev/null | sed -e 's/^/  git_head=/' >&2) || true
        (cd "{{ install_service_repo_path }}" && git describe --tags --long --dirty --abbrev=8 --match "v[0-9]*.[0-9]*.[0-9]*" --exclude "*-*" 2>/dev/null | sed -e 's/^/  git_describe=/' >&2) || true
      fi
      exit 1
    fi
  changed_when: false

- name: Create archive
  command: >-
    tar -czf "{{ install_service_archive_path }}"
    -C "{{ install_service_package_tmp }}"
    "{{ install_service_binary_basename }}"

- name: Generate checksum
  shell: |
    set -eu
    file="{{ install_service_archive_path }}"
    if command -v sha256sum >/dev/null 2>&1; then
      sha256sum "$file" > "${file}.sha256"
    elif command -v shasum >/dev/null 2>&1; then
      shasum -a 256 "$file" > "${file}.sha256"
    elif command -v sha256 >/dev/null 2>&1; then
      sha256 "$file" | awk '{print $4"  "FILENAME}' FILENAME="$(basename "$file")" > "${file}.sha256"
    else
      echo "No SHA256 tool found" >&2
      exit 1
    fi
