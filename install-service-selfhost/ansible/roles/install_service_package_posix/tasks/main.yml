---
- name: Ensure packaging variables provided
  assert:
    that:
      - install_service_release_version | length > 0
      - install_service_install_prefix | length > 0
      - install_service_asset_name | length > 0
      - install_service_archive_ext | length > 0
      - install_service_binary_basename | length > 0
    fail_msg: install_service_release_version, install_service_install_prefix, install_service_asset_name, and install_service_archive_ext are required

- name: Read build manifest (strict)
  when: install_service_require_build_info | default(true) | bool
  block:
    - name: Load build-info.json
      slurp:
        src: "{{ install_service_install_prefix }}/build-info.json"
      register: install_service_build_info_slurp

    - name: Parse build-info.json
      set_fact:
        install_service_build_info: "{{ install_service_build_info_slurp.content | b64decode | from_json }}"

    - name: Verify build-info.json matches release version
      assert:
        that:
          - install_service_build_info.git_describe is defined
          - (install_service_build_info.git_describe | string | trim) == (install_service_release_version | string | trim)
        fail_msg: >-
          build-info.json mismatch under {{ install_service_install_prefix }}.
          Expected git_describe={{ install_service_release_version }},
          got git_describe={{ install_service_build_info.git_describe | default('') }}

- name: Set staging paths
  set_fact:
    install_service_release_dir: "{{ install_service_remote_staging_root }}/{{ install_service_release_version }}"
    install_service_package_tmp: "{{ install_service_remote_staging_root }}/.tmp/{{ install_service_asset_name }}"
    install_service_archive_path: "{{ install_service_remote_staging_root }}/{{ install_service_release_version }}/{{ install_service_asset_name }}{{ install_service_archive_ext }}"

- name: Ensure staging directories exist
  file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - "{{ install_service_release_dir }}"
    - "{{ install_service_package_tmp }}"

- name: Set candidate binary paths
  set_fact:
    install_service_binary_candidates: >-
      {{
        (
          ([install_service_install_prefix ~ '/bin/' ~ (install_service_build_info.build_target | default('') | string | trim)]
            if (install_service_build_info is defined and (install_service_build_info.build_target | default('') | string | trim | length > 0))
            else [])
          + [
            install_service_install_prefix ~ '/bin/' ~ install_service_binary_basename,
            install_service_install_prefix ~ '/bin/cert_ctrl',
            install_service_install_prefix ~ '/' ~ install_service_binary_basename,
            install_service_install_prefix ~ '/cert_ctrl'
          ]
        )
      }}

- name: Stat candidate binaries
  stat:
    path: "{{ item }}"
  loop: "{{ install_service_binary_candidates }}"
  register: install_service_binary_candidate_stats

- name: Select first existing binary
  set_fact:
    install_service_binary_path_effective: >-
      {{
        (install_service_binary_candidate_stats.results
          | selectattr('stat.exists')
          | map(attribute='item')
          | list
          | first) | default('')
      }}

- name: Ensure installed binary exists
  assert:
    that:
      - install_service_binary_path_effective | length > 0
    fail_msg: >-
      Unable to locate built binary under install prefix {{ install_service_install_prefix }}.
      Candidates: {{ install_service_binary_candidates | join(', ') }}

- name: Stage build info (if present)
  copy:
    src: "{{ install_service_install_prefix }}/build-info.json"
    dest: "{{ install_service_package_tmp }}/build-info.json"
    mode: '0644'
    remote_src: true
  ignore_errors: "{{ not (install_service_require_build_info | default(true) | bool) }}"

- name: Stage binary for packaging
  copy:
    src: "{{ install_service_binary_path_effective }}"
    dest: "{{ install_service_package_tmp }}/{{ install_service_binary_basename }}"
    mode: '0755'
    remote_src: true

- name: Verify staged manifest matches release version (strict)
  when: install_service_require_build_info | default(true) | bool
  block:
    - name: Load staged build-info.json
      slurp:
        src: "{{ install_service_package_tmp }}/build-info.json"
      register: install_service_staged_build_info_slurp

    - name: Parse staged build-info.json
      set_fact:
        install_service_staged_build_info: "{{ install_service_staged_build_info_slurp.content | b64decode | from_json }}"

    - name: Assert staged build-info.json matches expected release version
      assert:
        that:
          - install_service_staged_build_info.git_describe is defined
          - (install_service_staged_build_info.git_describe | string | trim) == (install_service_release_version | string | trim)
        fail_msg: >-
          Staged build-info.json mismatch under {{ install_service_package_tmp }}.
          Expected git_describe={{ install_service_release_version }},
          got git_describe={{ install_service_staged_build_info.git_describe | default('') }}

- name: Verify staged binary version matches release version
  when: not (install_service_require_build_info | default(true) | bool)
  shell: |
    set -eu
    bin="{{ install_service_package_tmp }}/{{ install_service_binary_basename }}"
    expected="{{ install_service_release_version }}"
    asset_name="{{ install_service_asset_name }}"
    is_musl=0
    case "$asset_name" in
      *musl*) is_musl=1 ;;
    esac

    get_ver() {
      candidate="$1"
      v=$("$candidate" --version 2>/dev/null | head -n1 | tr -d '\r' || true)
      if [ -z "$v" ] && [ "$is_musl" = "1" ] && command -v docker >/dev/null 2>&1; then
        cand_dir=$(dirname "$candidate")
        cand_base=$(basename "$candidate")
        v=$(docker run --rm -v "$cand_dir:/staged:ro" alpine:3.19 sh -lc "/staged/$cand_base --version 2>/dev/null | head -n1 | tr -d '\\r'" 2>/dev/null || true)
      fi
      printf '%s' "$v"
    }

    manifest="{{ install_service_package_tmp }}/build-info.json"
    if [ -f "$manifest" ]; then
      mver=""
      if command -v python3 >/dev/null 2>&1; then
        mver=$(python3 -c 'import json,sys; print((json.load(open(sys.argv[1])) or {}).get("git_describe",""))' "$manifest" 2>/dev/null || true)
      fi
      if [ -z "$mver" ]; then
        mver=$(sed -n 's/.*"git_describe"[[:space:]]*:[[:space:]]*"\([^"\\]*\)".*/\1/p' "$manifest" | head -n1 || true)
      fi
      if [ -n "$mver" ] && [ "$mver" = "$expected" ]; then
        exit 0
      fi
    fi

    actual=$(get_ver "$bin")
    if [ -z "$actual" ]; then
      echo "error: unable to execute staged binary for version check" >&2
      echo "debug: staged bin=$bin" >&2
      if command -v file >/dev/null 2>&1; then
        file "$bin" >&2 || true
      fi
      if [ "$is_musl" = "1" ]; then
        echo "debug: musl binary may not run on host; version check will run inside alpine container when docker is available." >&2
        if ! command -v docker >/dev/null 2>&1; then
          echo "debug: docker not found; cannot run musl version check." >&2
        fi
      fi
      exit 1
    fi

    if [ "$actual" != "$expected" ]; then
      # If multiple binaries exist in the install prefix (e.g. cert-ctrl vs
      # cert_ctrl), try to restage the one that matches the expected version.
      for candidate in \
        "{{ install_service_install_prefix }}/bin/{{ install_service_binary_basename }}" \
        "{{ install_service_install_prefix }}/bin/cert_ctrl" \
        "{{ install_service_install_prefix }}/{{ install_service_binary_basename }}" \
        "{{ install_service_install_prefix }}/cert_ctrl"; do
        if [ -x "$candidate" ]; then
          cand_ver=$(get_ver "$candidate")
          if [ -n "$cand_ver" ] && [ "$cand_ver" = "$expected" ]; then
            cp -f "$candidate" "$bin"
            chmod 0755 "$bin" || true
            actual=$(get_ver "$bin")
            break
          fi
        fi
      done
    fi

    if [ "$actual" != "$expected" ]; then
      echo "error: packaged binary version mismatch" >&2
      echo "  expected: $expected" >&2
      echo "  actual:   $actual" >&2

      echo "debug: install prefix={{ install_service_install_prefix }}" >&2
      echo "debug: staged bin=$bin" >&2
      echo "debug: candidate binaries and versions:" >&2
      for candidate in \
        "{{ install_service_install_prefix }}/bin/{{ install_service_binary_basename }}" \
        "{{ install_service_install_prefix }}/bin/cert_ctrl" \
        "{{ install_service_install_prefix }}/{{ install_service_binary_basename }}" \
        "{{ install_service_install_prefix }}/cert_ctrl"; do
        if [ -e "$candidate" ]; then
          ls -l "$candidate" >&2 || true
          v=$(get_ver "$candidate")
          echo "  $candidate -> ${v:-<no version output>}" >&2
        else
          echo "  $candidate -> <missing>" >&2
        fi
      done

      if [ -d "{{ install_service_repo_path | default('') }}" ]; then
        echo "debug: repo={{ install_service_repo_path }}" >&2
        (cd "{{ install_service_repo_path }}" && git rev-parse HEAD 2>/dev/null | sed -e 's/^/  git_head=/' >&2) || true
        (cd "{{ install_service_repo_path }}" && git describe --tags --long --dirty --abbrev=8 --match "v[0-9]*.[0-9]*.[0-9]*" --exclude "*-*" 2>/dev/null | sed -e 's/^/  git_describe=/' >&2) || true
      fi
      exit 1
    fi
  changed_when: false

- name: Create archive
  shell: |
    set -eu
    tar -czf "{{ install_service_archive_path }}" -C "{{ install_service_package_tmp }}" .
  changed_when: false

- name: Generate checksum
  shell: |
    set -eu
    file="{{ install_service_archive_path }}"
    if command -v sha256sum >/dev/null 2>&1; then
      sha256sum "$file" > "${file}.sha256"
    elif command -v shasum >/dev/null 2>&1; then
      shasum -a 256 "$file" > "${file}.sha256"
    elif command -v sha256 >/dev/null 2>&1; then
      sha256 "$file" | awk '{print $4"  "FILENAME}' FILENAME="$(basename "$file")" > "${file}.sha256"
    else
      echo "No SHA256 tool found" >&2
      exit 1
    fi
