export const bashTemplate = `#!/bin/bash
# cert-ctrl installation script
# Generated by: {{BASE_URL}}
# Platform: {{PLATFORM}}-{{ARCHITECTURE}}
# Mirror: {{MIRROR_NAME}}
# Country: {{COUNTRY}}

set -euo pipefail

# Configuration from service
PLATFORM="{{PLATFORM}}"
ARCHITECTURE="{{ARCHITECTURE}}"
MIRROR_URL="{{MIRROR_URL}}"
BASE_URL="{{BASE_URL}}"
VERSION="{{VERSION}}"
# System installation only - user installation removed
# USER_INSTALL is always false
VERBOSE="\${VERBOSE:-{{VERBOSE}}}"
FORCE="\${FORCE:-{{FORCE}}}"
DRY_RUN="\${DRY_RUN:-{{DRY_RUN}}}"

# Advanced configuration (overridable via environment or flags)
CONFIG_DIR="\${CONFIG_DIR:-}"
INSTALL_SERVICE="\${INSTALL_SERVICE:-}"
ENABLE_SERVICE="\${ENABLE_SERVICE:-}"
SERVICE_NAME="\${SERVICE_NAME:-certctrl.service}"
SERVICE_ACCOUNT="\${SERVICE_ACCOUNT:-certctrl}"
SERVICE_DESCRIPTION="cert-ctrl certificate management agent"
NONINTERACTIVE="\${NONINTERACTIVE:-false}"
CHANNEL="\${CHANNEL:-stable}"

LAST_DOWNLOAD_URL=""
LAST_CHECKSUM_URL=""
CONFIG_DIR_PLACEHOLDER="{{CONFIG_DIR}}"
if [ -z "$CONFIG_DIR" ] && [ -n "$CONFIG_DIR_PLACEHOLDER" ]; then
    CONFIG_DIR="$CONFIG_DIR_PLACEHOLDER"
fi

# Override with environment or parameters
INSTALL_DIR="\${INSTALL_DIR:-{{INSTALL_DIR}}}"
if [ -z "$INSTALL_DIR" ]; then
    INSTALL_DIR="/usr/local/bin"
fi

# Colors
RED='\x1b[0;31m'
GREEN='\x1b[0;32m'
YELLOW='\x1b[1;33m'
BLUE='\x1b[0;34m'
NC='\x1b[0m'

# Logging functions
log_info() { echo -e "\${BLUE}[INFO]\${NC} $1" >&2; }
log_success() { echo -e "\${GREEN}[SUCCESS]\${NC} $1" >&2; }
log_warning() { echo -e "\${YELLOW}[WARNING]\${NC} $1" >&2; }
log_error() { echo -e "\${RED}[ERROR]\${NC} $1" >&2; }
log_verbose() {
    if [ "$VERBOSE" = "true" ]; then
        echo -e "\${BLUE}[VERBOSE]\${NC} $1" >&2
    fi
}

# Detect platform if not provided
detect_platform() {
    if [ -n "$PLATFORM" ] && [ "$PLATFORM" != "unknown" ]; then
        echo "$PLATFORM-$ARCHITECTURE"
        return
    fi
    
    local platform=""
    local arch=""
    
    case "$(uname -s)" in
        Linux*)     platform="linux" ;;
        Darwin*)    platform="macos" ;;
        *)          log_error "Unsupported platform: $(uname -s)"; exit 1 ;;
    esac
    
    case "$(uname -m)" in
        x86_64|amd64)   arch="x64" ;;
        aarch64|arm64)  arch="arm64" ;;
        armv7l)         arch="arm" ;;
        *)              arch="x64" ;; # Default
    esac
    
    echo "\${platform}-\${arch}"
}

# Check dependencies
check_dependencies() {
    local deps=("curl" "tar" "gzip" "sha256sum")

    if [ "$INSTALL_SERVICE" = "true" ]; then
        deps+=("systemctl")
    fi

    for dep in "\${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            log_error "Required dependency '$dep' is not installed."
            exit 1
        fi
    done
    
    log_verbose "All dependencies are available"
}

# Resolve version
resolve_version() {
    if [ "$VERSION" = "latest" ]; then
        log_info "Resolving latest version..."
        local latest_url="$BASE_URL/api/version/latest"
        
        if command -v jq &> /dev/null; then
            VERSION=$(curl -fsSL "$latest_url" | jq -r '.version')
        else
            VERSION=$(curl -fsSL "$latest_url" | grep '"version":' | sed -E 's/.*"version": "([^\"]+)".*/\\1/')
        fi
        
        if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
            log_error "Failed to resolve latest version"
            exit 1
        fi
        
        log_verbose "Resolved latest version: $VERSION"
    fi
}

# Download binary
download_binary() {
    local platform_arch="$1"
    
    # Use proxy if available, otherwise direct GitHub
    local download_url
    if [ "$MIRROR_URL" = "$BASE_URL/releases/proxy" ]; then
        download_url="$MIRROR_URL/$VERSION/cert-ctrl-$platform_arch.tar.gz"
    else
        download_url="$MIRROR_URL/{{GITHUB_REPO_OWNER}}/{{GITHUB_REPO_NAME}}/releases/download/$VERSION/cert-ctrl-$platform_arch.tar.gz"
    fi

    LAST_DOWNLOAD_URL="$download_url"
    
    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: Would download cert-ctrl from $download_url"
        echo ""
        return 0
    fi

    local temp_file=$(mktemp)
    
    log_info "Downloading cert-ctrl $VERSION for $platform_arch..."
    log_verbose "Download URL: $download_url"
    
    if ! curl -fsSL "$download_url" -o "$temp_file"; then
        log_error "Failed to download cert-ctrl"
        rm -f "$temp_file"
        exit 1
    fi
    
    echo "$temp_file"
}

download_checksum() {
    local platform_arch="$1"

    if [ "$DRY_RUN" = "true" ]; then
        LAST_CHECKSUM_URL=""
        return 0
    fi

    local checksum_url
    if [ "$MIRROR_URL" = "$BASE_URL/releases/proxy" ]; then
        checksum_url="$MIRROR_URL/$VERSION/cert-ctrl-$platform_arch.tar.gz.sha256"
    else
        checksum_url="$MIRROR_URL/{{GITHUB_REPO_OWNER}}/{{GITHUB_REPO_NAME}}/releases/download/$VERSION/cert-ctrl-$platform_arch.tar.gz.sha256"
    fi

    LAST_CHECKSUM_URL="$checksum_url"

    local checksum_file=$(mktemp)
    log_verbose "Fetching checksum from $checksum_url"

    if curl -fsSL "$checksum_url" -o "$checksum_file"; then
        echo "$checksum_file"
        return 0
    fi

    log_warning "Checksum file not available; skipping verification"
    rm -f "$checksum_file"
    echo ""
}

verify_checksum() {
    local archive_file="$1"
    local checksum_file="$2"

    if [ -z "$checksum_file" ]; then
        return 0
    fi

    if [ ! -f "$checksum_file" ]; then
        log_warning "Checksum file missing; skipping verification"
        return 0
    fi

    log_info "Verifying archive integrity..."

    local expected=$(awk 'NF>=1 {print $1; exit}' "$checksum_file")
    local actual=$(sha256sum "$archive_file" | awk '{print $1}')

    if [ -z "$expected" ]; then
        log_warning "Checksum file empty; skipping verification"
        return 0
    fi

    if [ "$expected" != "$actual" ]; then
        log_error "Checksum verification failed"
        log_verbose "Expected: $expected"
        log_verbose "Actual:   $actual"
        exit 1
    fi

    log_success "Checksum verified"
}

prompt_yes_no() {
    local message="$1"

    if [ "$NONINTERACTIVE" = "true" ]; then
        return 0
    fi

    read -p "$message [y/N]: " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        return 0
    fi
    return 1
}

install_config_files() {
    local extract_dir="$1"

    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: Would place configuration into $CONFIG_DIR"
        return 0
    fi

    local config_source=""
    if [ -d "$extract_dir/config" ]; then
        config_source="$extract_dir/config"
    elif [ -d "$extract_dir/etc/certctrl" ]; then
        config_source="$extract_dir/etc/certctrl"
    fi

    if [ -z "$config_source" ]; then
        log_verbose "No configuration directory found in archive"
        return 0
    fi

    log_info "Installing configuration to $CONFIG_DIR"
    if [ -d "$CONFIG_DIR" ] && [ -n "$(ls -A "$CONFIG_DIR" 2>/dev/null)" ] && [ "$FORCE" = "false" ]; then
        if [ "$NONINTERACTIVE" = "true" ]; then
            log_info "Configuration directory exists but continuing (non-interactive mode)"
        else
            log_warning "Configuration directory $CONFIG_DIR already exists and contains files"
            log_info "To overwrite: Use ?force in URL or FORCE=true with sudo -E"
            log_info "Skipping configuration install"
            return 0
        fi
    fi
    mkdir -p "$CONFIG_DIR"
    cp -R "$config_source/." "$CONFIG_DIR/"
    log_success "Configuration installed"
}

ensure_service_account() {
    local account="$SERVICE_ACCOUNT"

    if [ "$account" = "" ] || [ "$account" = "root" ]; then
        return 0
    fi

    if id "$account" &> /dev/null; then
        return 0
    fi

    if command -v useradd &> /dev/null; then
        log_info "Creating service account $account"
        useradd --system --no-create-home --shell /usr/sbin/nologin "$account"
    else
        log_warning "useradd not available; please ensure account $account exists"
    fi
}

create_systemd_unit() {
    cat > "/etc/systemd/system/$SERVICE_NAME" << 'EOF'
[Unit]
Description=@@DESCRIPTION@@
After=network-online.target
Wants=network-online.target
StartLimitIntervalSec=0

[Service]
Type=simple
Restart=always
RestartSec=5
User=@@SERVICE_USER@@
Group=@@SERVICE_USER@@
WorkingDirectory=@@CONFIG_DIR@@
ExecStart=@@BINARY_PATH@@ --config-dirs @@CONFIG_DIR@@
StandardOutput=journal
StandardError=journal
SyslogIdentifier=cert-ctrl

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=@@CONFIG_DIR@@

[Install]
WantedBy=multi-user.target
EOF
}

install_service_unit() {

    if [ "$INSTALL_SERVICE" != "true" ]; then
        log_verbose "Service installation disabled"
        return 0
    fi

    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: Would install systemd unit $SERVICE_NAME"
        return 0
    fi

    if [ "$EUID" -ne 0 ]; then
        log_warning "Service installation requires root privileges (skipping service setup)"
        log_info "To install service manually after installation:"
        log_info "  sudo systemctl enable --now $SERVICE_NAME"
        return 0
    fi

    if ! command -v systemctl &> /dev/null; then
        log_warning "systemctl not available; skipping service installation"
        return 0
    fi

    ensure_service_account

    log_info "Installing systemd unit at /etc/systemd/system/$SERVICE_NAME"
    if [ -f "/etc/systemd/system/$SERVICE_NAME" ] && [ "$FORCE" = "false" ]; then
        if [ "$NONINTERACTIVE" = "true" ]; then
            log_info "Overwriting existing service unit (non-interactive mode)"
        else
            log_warning "Service $SERVICE_NAME already exists."
            log_info "To overwrite: Use ?force in URL or FORCE=true with sudo -E"
            log_info "Skipping service installation"
            return 0
        fi
    fi

    create_systemd_unit

    # Substitute placeholders in the service file
    sed -i "s|@@BINARY_PATH@@|$INSTALL_DIR/cert-ctrl|g" "/etc/systemd/system/$SERVICE_NAME"
    sed -i "s|@@CONFIG_DIR@@|$CONFIG_DIR|g" "/etc/systemd/system/$SERVICE_NAME"
    sed -i "s|@@SERVICE_USER@@|$SERVICE_ACCOUNT|g" "/etc/systemd/system/$SERVICE_NAME"
    sed -i "s|@@DESCRIPTION@@|$SERVICE_DESCRIPTION|g" "/etc/systemd/system/$SERVICE_NAME"

    # Ensure config directory exists and has proper permissions
    if [ ! -d "$CONFIG_DIR" ]; then
        log_info "Creating config directory $CONFIG_DIR"
        mkdir -p "$CONFIG_DIR"
    fi
    chown -R "$SERVICE_ACCOUNT:$SERVICE_ACCOUNT" "$CONFIG_DIR" 2>/dev/null || true
    chmod 755 "$CONFIG_DIR"

    systemctl daemon-reload
    log_success "Systemd unit installed successfully"

    if [ "$ENABLE_SERVICE" = "true" ]; then
        log_info "Enabling and starting $SERVICE_NAME"
        if systemctl enable --now "$SERVICE_NAME"; then
            log_success "Service $SERVICE_NAME started successfully"
        else
            log_warning "Service installation completed but failed to start"
            log_info "Check logs with: journalctl -u $SERVICE_NAME"
            log_info "Start manually with: systemctl start $SERVICE_NAME"
        fi
    else
        log_info "Service installed. Enable manually with: systemctl enable --now $SERVICE_NAME"
    fi
}

# Install binary
install_binary() {
    local temp_file="$1"
    local platform_arch="$2"
    
    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: Would install to $INSTALL_DIR"
        if [ "$INSTALL_SERVICE" = "true" ]; then
            log_info "DRY RUN: Would install systemd unit $SERVICE_NAME"
        fi
        return 0
    fi
    
    mkdir -p "$INSTALL_DIR"
    
    log_info "Installing to $INSTALL_DIR..."
    
    # Extract
    local extract_dir=$(mktemp -d)
    if ! tar -xzf "$temp_file" -C "$extract_dir"; then
        log_error "Failed to extract downloaded file"
        rm -rf "$extract_dir"
        exit 1
    fi
    
    # Find binary
    local binary_path=""
    if [ -f "$extract_dir/cert-ctrl" ]; then
        binary_path="$extract_dir/cert-ctrl"
    elif [ -f "$extract_dir/bin/cert-ctrl" ]; then
        binary_path="$extract_dir/bin/cert-ctrl"
    else
        log_error "cert-ctrl binary not found in archive"
        rm -rf "$extract_dir"
        exit 1
    fi
    
    # Check existing installation
    if [ -f "$INSTALL_DIR/cert-ctrl" ] && [ "$FORCE" = "false" ]; then
        local current_version=""
        if [ -x "$INSTALL_DIR/cert-ctrl" ]; then
            current_version=$("$INSTALL_DIR/cert-ctrl" --version 2>/dev/null || echo "unknown")
        fi
        
        log_warning "cert-ctrl is already installed at $INSTALL_DIR/cert-ctrl"
        if [ -n "$current_version" ]; then
            log_info "Current version: $current_version"
            log_info "New version: $VERSION"
        fi
        log_info ""
        log_info "To proceed with installation, choose one of:"
        log_info "  1. URL parameter:   curl -fsSL \"https://install.lets-script.com/install.sh?force\" | sudo bash"
        log_info "  2. Environment var: FORCE=true curl -fsSL https://install.lets-script.com/install.sh | sudo -E bash"
        log_info "  3. Remove existing: sudo rm $INSTALL_DIR/cert-ctrl && curl -fsSL https://install.lets-script.com/install.sh | sudo bash"
        log_info ""
        log_error "Installation stopped. Use one of the options above to continue."
        rm -rf "$extract_dir"
        exit 1
    fi
    
    # Install
    chmod +x "$binary_path"
    cp "$binary_path" "$INSTALL_DIR/cert-ctrl"
    log_success "Binary installed"

    install_config_files "$extract_dir"
    install_service_unit

    rm -rf "$extract_dir"

    log_success "cert-ctrl installed successfully!"
}

# Setup PATH
setup_path() {
    # System installation - /usr/local/bin should already be in PATH
    return 0
}

# Verify installation
verify_installation() {
    local binary_path="$INSTALL_DIR/cert-ctrl"
    
    if [ ! -f "$binary_path" ]; then
        log_error "Installation failed: binary not found"
        exit 1
    fi
    
    if "$binary_path" --version &>/dev/null; then
        local version=$("$binary_path" --version 2>/dev/null | head -n1)
        log_success "Installation verified! Version: $version"
        return 0
    else
        log_warning "Binary installed but version check failed"
        
        # Try to run the binary and show error output
        echo ""
        log_info "Trying to diagnose the issue..."
        local error_output
        error_output=$("$binary_path" 2>&1 || true)
        
        # Check if it's a glibc version issue
        if echo "$error_output" | grep -q "GLIBC_"; then
            log_error "Your system is missing required glibc versions!"
            echo ""
            
            # Show current glibc version
            local current_glibc=""
            if [ -f /lib/x86_64-linux-gnu/libc.so.6 ]; then
                current_glibc=$(/lib/x86_64-linux-gnu/libc.so.6 2>&1 | grep -o "release version [0-9]*\.[0-9]*" | awk '{print $NF}')
            fi
            
            if [ -z "$current_glibc" ] && command -v ldd &>/dev/null; then
                current_glibc=$(ldd --version 2>&1 | head -1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            fi
            
            if [ -n "$current_glibc" ]; then
                log_warning "Your system has: glibc $current_glibc"
            else
                log_warning "Unable to detect your current glibc version"
            fi
            
            # Extract and show required versions
            local required_versions
            required_versions=$(echo "$error_output" | grep -o "GLIBC_[0-9.]*" | sort -u | tr '\n' ' ')
            log_warning "Required versions: $required_versions"
            
            echo ""
            
            # Detect OS and provide specific advice
            if [ -f /etc/os-release ]; then
                local os_id=$(grep "^ID=" /etc/os-release | cut -d'=' -f2 | tr -d '"')
                local version_id=$(grep "^VERSION_ID=" /etc/os-release | cut -d'=' -f2 | tr -d '"')
                
                log_info "Your system: $os_id $version_id"
                echo ""
                
                case "$os_id" in
                    ubuntu)
                        case "$version_id" in
                            "24.04"|"23.10"|"23.04")
                                log_success "Ubuntu $version_id has compatible glibc - update your packages:"
                                echo "  sudo apt update && sudo apt full-upgrade -y"
                                ;;
                            "22.04")
                                log_warning "Ubuntu 22.04 LTS has glibc 2.35, but cert-ctrl requires glibc 2.36+."
                                echo ""
                                log_info "RECOMMENDED: Upgrade to Ubuntu 24.04 LTS (latest stable)"
                                echo "  sudo do-release-upgrade"
                                echo ""
                                log_info "OR try updating current Ubuntu packages (may not work):"
                                echo "  sudo apt update && sudo apt full-upgrade -y"
                                ;;
                            "20.04")
                                log_error "Ubuntu 20.04 LTS has glibc 2.31, which is too old for cert-ctrl."
                                echo ""
                                log_info "RECOMMENDED: Upgrade to Ubuntu 24.04 LTS"
                                echo "  sudo do-release-upgrade"
                                ;;
                            *)
                                log_info "Try updating your Ubuntu packages:"
                                echo "  sudo apt update && sudo apt full-upgrade -y"
                                ;;
                        esac
                        ;;
                    debian)
                        log_info "For Debian $version_id, try:"
                        echo "  sudo apt update && sudo apt full-upgrade -y"
                        ;;
                    rhel|centos|rocky|almalinux|fedora)
                        log_info "For RHEL/CentOS/Rocky/Fedora, update packages:"
                        echo "  sudo dnf update -y"
                        ;;
                    *)
                        log_info "Try updating your system packages:"
                        echo "  sudo apt update && sudo apt upgrade -y  # Debian-based"
                        echo "  sudo dnf update -y                    # RHEL-based"
                        ;;
                esac
            fi
            
            echo ""
            log_info "Alternative options:"
            echo "  1. Use Docker: docker run cert-ctrl --version"
            echo "  2. Build from source on your system"
            echo "  3. Use a container with compatible glibc"
        else
            log_error "Binary failed to run:"
            echo "$error_output"
        fi
        
        echo ""
        log_error "Installation incomplete due to runtime dependencies."
        return 1
    fi
}

# Main function
main() {
    log_info "Starting cert-ctrl installation..."
    log_verbose "Service URL: $BASE_URL"
    log_verbose "Mirror: $MIRROR_URL"
    log_verbose "Install directory: $INSTALL_DIR"
    log_verbose "Config directory: $CONFIG_DIR"
    log_verbose "Service install: $INSTALL_SERVICE (enable=$ENABLE_SERVICE)"
    
    check_dependencies
    
    local platform_arch=$(detect_platform)
    log_verbose "Platform: $platform_arch"
    
    resolve_version
    
    if [ ! -w "$(dirname "$INSTALL_DIR")" ] && [ "$EUID" -ne 0 ]; then
        log_error "Installation requires root privileges"
        exit 1
    fi
    
    local temp_file=$(download_binary "$platform_arch")

    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: No changes were made"
        return 0
    fi

    if [ -z "$temp_file" ]; then
        log_error "Download failed"
        exit 1
    fi

    local checksum_file=$(download_checksum "$platform_arch")
    verify_checksum "$temp_file" "$checksum_file"
    
    install_binary "$temp_file" "$platform_arch"
    
    rm -f "$temp_file"
    if [ -n "$checksum_file" ]; then
        rm -f "$checksum_file"
    fi
    
    setup_path
    verify_installation
    
    echo
    log_success "cert-ctrl installation completed!"
    echo
    echo "Next steps:"
    echo "  - Run: cert-ctrl --help"
    if [ "$INSTALL_SERVICE" = "true" ]; then
        if [ "$ENABLE_SERVICE" = "true" ]; then
            echo "  - Check service status: systemctl status $SERVICE_NAME"
        else
            echo "  - Enable service when ready: sudo systemctl enable --now $SERVICE_NAME"
        fi
    fi
    echo
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --version)
            VERSION="$2"
            shift 2
            ;;
        --install-dir|--dir)
            INSTALL_DIR="$2"
            shift 2
            ;;
        --config-dir)
            CONFIG_DIR="$2"
            shift 2
            ;;
        --service)
            INSTALL_SERVICE="true"
            ENABLE_SERVICE="true"
            shift
            ;;
        --no-service)
            INSTALL_SERVICE="false"
            ENABLE_SERVICE="false"
            shift
            ;;
        --enable-service)
            ENABLE_SERVICE="true"
            shift
            ;;
        --no-enable)
            ENABLE_SERVICE="false"
            shift
            ;;
        --non-interactive|--yes|-y)
            NONINTERACTIVE="true"
            FORCE=true
            shift
            ;;
        --channel)
            CHANNEL="$2"
            shift 2
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help|-h)
            echo "cert-ctrl installation script"
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  --user-install    Install to user directory"
            echo "  --version VER     Install specific version"
            echo "  --install-dir DIR Custom install directory"
            echo "  --config-dir DIR  Override configuration directory"
            echo "  --force           Overwrite existing installation"
            echo "  --service         Install and enable systemd service"
            echo "  --no-service      Skip systemd service installation"
            echo "  --enable-service  Enable service after install"
            echo "  --no-enable       Install service but do not enable"
            echo "  --non-interactive Run without prompts (assumes yes)"
            echo "  --verbose         Enable verbose output"
            echo "  --dry-run         Show what would be done"
            echo "  --help            Show this help"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

if [ -z "$CONFIG_DIR" ]; then
    CONFIG_DIR="/etc/certctrl"
fi

if [ -z "$INSTALL_SERVICE" ]; then
    INSTALL_SERVICE="true"
fi

if [ -z "$ENABLE_SERVICE" ]; then
    ENABLE_SERVICE="$INSTALL_SERVICE"
fi

if [ -z "$FORCE" ]; then
    FORCE="false"
fi

if [ -z "$DRY_RUN" ]; then
    DRY_RUN="false"
fi

if [ -z "$VERBOSE" ]; then
    VERBOSE="false"
fi

# Run installation
main
`;
