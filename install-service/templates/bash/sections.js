// Auto-generated from install.sh.js; edit sections for maintainability
export const bashTemplateSections = [
String.raw`#!/bin/bash
# cert-ctrl installation script
# Generated by: {{BASE_URL}}
# Platform: {{PLATFORM}}-{{ARCHITECTURE}}
# Mirror: {{MIRROR_NAME}}
# Country: {{COUNTRY}}

set -euo pipefail

# Configuration from service
PLATFORM="{{PLATFORM}}"
ARCHITECTURE="{{ARCHITECTURE}}"
MIRROR_URL="{{MIRROR_URL}}"
BASE_URL="{{BASE_URL}}"
VERSION="{{VERSION}}"
# System installation only - user installation removed
# USER_INSTALL is always false
VERBOSE="\${VERBOSE:-{{VERBOSE}}}"
FORCE="\${FORCE:-{{FORCE}}}"
DRY_RUN="\${DRY_RUN:-{{DRY_RUN}}}"

# Advanced configuration (overridable via environment or flags)
CONFIG_DIR="\${CONFIG_DIR:-}"
INSTALL_SERVICE="\${INSTALL_SERVICE:-}"
ENABLE_SERVICE="\${ENABLE_SERVICE:-}"
SERVICE_NAME="\${SERVICE_NAME:-certctrl.service}"
SERVICE_ACCOUNT="\${SERVICE_ACCOUNT:-root}"
SERVICE_DESCRIPTION="cert-ctrl certificate management agent"
NONINTERACTIVE="\${NONINTERACTIVE:-false}"
CHANNEL="\${CHANNEL:-stable}"

LAST_DOWNLOAD_URL=""
LAST_CHECKSUM_URL=""
CONFIG_DIR_PLACEHOLDER="{{CONFIG_DIR}}"
if [ -z "$CONFIG_DIR" ] && [ -n "$CONFIG_DIR_PLACEHOLDER" ]; then
    CONFIG_DIR="$CONFIG_DIR_PLACEHOLDER"
fi

STATE_DIR="\${STATE_DIR:-/var/lib/certctrl}"
STATE_DIR_PLACEHOLDER="{{STATE_DIR}}"
if [ -z "$STATE_DIR" ] && [ -n "$STATE_DIR_PLACEHOLDER" ]; then
    STATE_DIR="$STATE_DIR_PLACEHOLDER"
fi
STATE_DIR_NAME="$(basename "$STATE_DIR")"
RESTART_SERVICE_AFTER_INSTALL="false"
SHA256_CMD=()

OS_ID=""
OS_VERSION_ID=""
OS_NAME=""
SERVICE_MANAGER=""

find_command_path() {
    local cmd="$1"
    local resolved
    resolved=$(command -v "$cmd" 2>/dev/null || true)
    if [ -n "$resolved" ]; then
        echo "$resolved"
        return 0
    fi
    if [ -x "/sbin/$cmd" ]; then
        echo "/sbin/$cmd"
        return 0
    fi
    if [ -x "/usr/sbin/$cmd" ]; then
        echo "/usr/sbin/$cmd"
        return 0
    fi
    return 1
}

restore_selinux_context() {
    local target_path="$1"

    if [ -z "$target_path" ] || [ ! -e "$target_path" ]; then
        return 0
    fi

    if ! command -v selinuxenabled >/dev/null 2>&1; then
        return 0
    fi

    if ! selinuxenabled >/dev/null 2>&1; then
        return 0
    fi

    if command -v restorecon >/dev/null 2>&1; then
        if restorecon -F "$target_path" >/dev/null 2>&1; then
            log_verbose "SELinux context refreshed for $target_path"
        else
            log_warning "restorecon failed for $target_path; systemd may not see the unit"
        fi
        return 0
    fi

    if command -v chcon >/dev/null 2>&1 && [ -f /usr/lib/systemd/system/sshd.service ]; then
        if chcon --reference=/usr/lib/systemd/system/sshd.service "$target_path" >/dev/null 2>&1; then
            log_verbose "Applied SELinux context from sshd.service to $target_path"
        else
            log_warning "Unable to set SELinux context for $target_path"
        fi
        return 0
    fi

    log_warning "SELinux detected but restorecon/chcon unavailable; certctrl.service may require manual relabel"
}

# Override with environment or parameters
INSTALL_DIR="\${INSTALL_DIR:-{{INSTALL_DIR}}}"
if [ -z "$INSTALL_DIR" ]; then
    INSTALL_DIR="/usr/local/bin"
fi

# Colors
RED='\x1b[0;31m'
GREEN='\x1b[0;32m'
YELLOW='\x1b[1;33m'
BLUE='\x1b[0;34m'
NC='\x1b[0m'

# Logging functions
log_info() { echo -e "\${BLUE}[INFO]\${NC} $1" >&2; }
log_success() { echo -e "\${GREEN}[SUCCESS]\${NC} $1" >&2; }
log_warning() { echo -e "\${YELLOW}[WARNING]\${NC} $1" >&2; }
log_error() { echo -e "\${RED}[ERROR]\${NC} $1" >&2; }
log_verbose() {
    if [ "$VERBOSE" = "true" ]; then
        echo -e "\${BLUE}[VERBOSE]\${NC} $1" >&2
    fi
}

detect_os_release() {
    if [ -f /etc/os-release ]; then
        OS_ID=$(grep -E '^ID=' /etc/os-release | head -n1 | cut -d'=' -f2 | tr -d '"')
        OS_VERSION_ID=$(grep -E '^VERSION_ID=' /etc/os-release | head -n1 | cut -d'=' -f2 | tr -d '"')
        OS_NAME=$(grep -E '^PRETTY_NAME=' /etc/os-release | head -n1 | cut -d'=' -f2 | tr -d '"')
        return 0
    fi

    if command -v uname >/dev/null 2>&1; then
        local uname_s
        uname_s=$(uname -s 2>/dev/null || true)
        if [ "$uname_s" = "FreeBSD" ]; then
            OS_ID="freebsd"
            OS_NAME="FreeBSD"
            if command -v freebsd-version >/dev/null 2>&1; then
                OS_VERSION_ID=$(freebsd-version -u 2>/dev/null | cut -d'-' -f1)
            else
                OS_VERSION_ID=""
            fi
            return 0
        fi
    OS_ID="unknown"
    OS_VERSION_ID=""
    OS_NAME="Unknown Linux"
}

detect_service_manager() {
    if [ "$OS_ID" = "freebsd" ]; then
        echo "freebsd-rcd"
        return 0
    fi

    if [ "$OS_ID" = "alpine" ]; then
        echo "openrc"
        return 0
    fi

    local rc_update_path
    if rc_update_path=$(find_command_path rc-update 2>/dev/null); then
        if [ -n "$rc_update_path" ]; then
            echo "openrc"
            return 0
        fi
    fi

    if command -v systemctl >/dev/null 2>&1; then
        echo "systemd"
        return 0
    fi

    echo "none"
}

get_openrc_service_name() {
    local name="$SERVICE_NAME"
    if [[ "$name" == *.service ]]; then
        name="\${name%.service}"
    fi
    echo "$name"
}

get_freebsd_service_name() {
    local name="$SERVICE_NAME"
    if [[ "$name" == *.service ]]; then
        name="\${name%.service}"
    fi
    echo "$name"
}

is_suse_like() {
    case "$OS_ID" in
        sles|sled|suse|sles_sap|opensuse*|leap)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

needs_suse_openssl_compat() {
    if ! is_suse_like; then
        return 1
    fi
    if ! command -v ldconfig >/dev/null 2>&1; then
        return 0
    fi
    if ldconfig -p | grep -q 'libssl.so.1.1'; then
        return 0
    fi
    return 1
}

is_musl_based() {
    if [ "$OS_ID" = "alpine" ]; then
        return 0
    fi

    if [ -n "$OS_NAME" ] && printf '%s' "$OS_NAME" | grep -qi 'musl'; then
        return 0
    fi

    if command -v ldd >/dev/null 2>&1; then
        if ldd --version 2>&1 | grep -qi 'musl'; then
            return 0
        fi
    fi

    if compgen -G "/lib/ld-musl-*.so*" >/dev/null 2>&1; then
        return 0
    fi

    return 1
}

ensure_usr_bin_symlink() {
    if ! is_suse_like; then
        return 0
    fi
    if [ "$EUID" -ne 0 ]; then
        log_verbose "Skipping /usr/bin symlink creation (not running as root)"
        return 0
    fi
    local target="$INSTALL_DIR/cert-ctrl"
    local symlink="/usr/bin/cert-ctrl"
    if [ ! -x "$target" ]; then
        return 0
    fi
    if [ -e "$symlink" ]; then
        return 0
    fi
    if [ ! -w "/usr/bin" ]; then
        log_warning "Cannot create /usr/bin symlink; directory is not writable"
        return 0
    fi
    log_info "Adding /usr/bin/cert-ctrl symlink for SUSE sudo PATH"
    ln -s "$target" "$symlink"
}

ensure_suse_openssl_dependencies() {
    if ! is_suse_like; then
        return 0
    fi

    if [ "$EUID" -ne 0 ]; then
        log_warning "Detected SUSE-based distro but installer lacks root privileges to install OpenSSL compatibility packages."
        log_info "Install manually if TLS errors persist: sudo zypper install -y libopenssl1_1 libopenssl1_1-hmac"
        return 0
    fi

    if ! needs_suse_openssl_compat; then
        log_verbose "OpenSSL 1.1 compatibility libraries already present"
        return 0
    fi

    if command -v zypper >/dev/null 2>&1; then
        log_info "Installing OpenSSL 1.1 compatibility libraries for SUSE..."
        if zypper --non-interactive install -y libopenssl1_1 libopenssl1_1-hmac >/dev/null 2>&1; then
            log_success "Installed libopenssl1_1 compatibility libraries"
        else
            log_warning "Failed to install libopenssl1_1 automatically. Run: sudo zypper install -y libopenssl1_1 libopenssl1_1-hmac"
        fi
    else
        log_warning "zypper not found. Install libopenssl1_1 manually to resolve TLS issues on $OS_NAME."
    fi
}

apply_distro_specific_fixes() {
    ensure_usr_bin_symlink
    ensure_suse_openssl_dependencies
}

get_installed_version() {
    local binary_path="$1"

    if [ -z "$binary_path" ] || [ ! -x "$binary_path" ]; then
        echo ""
        return 0
    fi

    local version_output=""
    if version_output=$("$binary_path" --version 2>/dev/null); then
        version_output=$(printf '%s\n' "$version_output" | head -n1)
    else
        version_output=""
    fi

    if [ -z "$version_output" ]; then
        echo ""
        return 0
    fi

    echo "$version_output"
}

maybe_skip_install() {
    if [ "$FORCE" = "true" ]; then
        log_verbose "Force install requested; skipping existing version check"
        return 0
    fi

    local binary_path="$INSTALL_DIR/cert-ctrl"

    if [ ! -x "$binary_path" ]; then
        log_verbose "No existing cert-ctrl installation detected at $binary_path"
        return 0
    fi

    local installed_version
    installed_version=$(get_installed_version "$binary_path")

    if [ -z "$installed_version" ]; then
        log_verbose "Existing cert-ctrl binary found but version could not be determined"
        return 0
    fi

    local requested="\${VERSION#v}"
    local installed_trim="\${installed_version#v}"

    if [ "$installed_trim" = "$requested" ]; then
        log_success "cert-ctrl $installed_version is already installed at $binary_path"
        log_info "Skipping download because the requested version is already present."
        log_info "To reinstall anyway, run: curl -fsSL \"$BASE_URL/install.sh?force=1\" | sudo bash"
        exit 0
    fi

    log_verbose "Installed version $installed_version differs from requested $VERSION; continuing with download"
}

# Detect platform if not provided
detect_platform() {
    if [ -n "$PLATFORM" ] && [ "$PLATFORM" != "unknown" ]; then
        echo "$PLATFORM-$ARCHITECTURE"
        return
    fi
    
    local platform=""
    local arch=""
    
    case "$(uname -s)" in
        Linux*)     platform="linux" ;;
        Darwin*)    platform="macos" ;;
        FreeBSD*)   platform="freebsd" ;;
        *)          log_error "Unsupported platform: $(uname -s)"; exit 1 ;;
    esac
    
    case "$(uname -m)" in
        x86_64|amd64)   arch="x64" ;;
        aarch64|arm64)  arch="arm64" ;;
        armv7l)         arch="arm" ;;
        *)              arch="x64" ;; # Default
    esac
    
    echo "\${platform}-\${arch}"
}

should_use_openssl3_artifact() {
    if is_musl_based; then
        return 1
    fi

    if ! is_suse_like; then
        return 1
    fi

    if [ -z "$OS_VERSION_ID" ]; then
        return 1
    fi

    local version_major="\${OS_VERSION_ID%%.*}"
    if printf '%s' "$version_major" | grep -Eq '^[0-9]+$'; then
        if [ "$version_major" -ge 16 ]; then
            return 0
        fi
    fi

    if printf '%s' "$OS_VERSION_ID" | grep -Eq '^20[2-9][0-9]'; then
        return 0
    fi

    return 1
}

select_artifact_slug() {
    local platform_arch="$1"
    if [ -z "$platform_arch" ]; then
        echo ""
        return 0
    fi

    local platform="\${platform_arch%%-*}"
    local arch="\${platform_arch#*-}"
    if [ "$platform" = "$platform_arch" ]; then
        arch=""
    fi

    if [ "$platform" = "linux" ]; then
        if [ "$arch" = "x64" ] && is_musl_based; then
            echo "linux-musl-$arch"
            return 0
        fi

        if [ "$arch" = "x64" ] && should_use_openssl3_artifact; then
            echo "linux-$arch-openssl3"
            return 0
        fi
    fi

    echo "$platform_arch"
}`,
String.raw`# Check dependencies
set_checksum_tool() {
    if command -v sha256sum >/dev/null 2>&1; then
        SHA256_CMD=(sha256sum)
        return 0
    fi

    if command -v shasum >/dev/null 2>&1; then
        SHA256_CMD=(shasum -a 256)
        return 0
    fi

    log_error "Required dependency 'sha256sum' (or 'shasum') is not installed."
    log_info "macOS: brew install coreutils"
    exit 1
}

check_dependencies() {
    local deps=("curl" "tar" "gzip")
    if [ "$INSTALL_SERVICE" = "true" ]; then
        case "$SERVICE_MANAGER" in
            freebsd-rcd)
                deps+=("service" "sysrc")
                ;;
            systemd)
                deps+=("systemctl")
                ;;
            openrc)
                if ! find_command_path rc-update >/dev/null 2>&1; then
                    log_warning "rc-update not found; OpenRC service will require manual registration"
                fi
                if ! find_command_path rc-service >/dev/null 2>&1; then
                    log_warning "rc-service not found; OpenRC service management will require manual commands"
                fi
                ;;
            *)
                log_warning "No supported service manager detected; skipping service installation"
                INSTALL_SERVICE="false"
                ENABLE_SERVICE="false"
                ;;
        esac
    fi

    for dep in "\${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            log_error "Required dependency '$dep' is not installed."
            exit 1
        fi
    done
    
    set_checksum_tool

    log_verbose "All dependencies are available"
}

# Resolve version
resolve_version() {
    if [ "$VERSION" = "latest" ]; then
        log_info "Resolving latest version..."
        local latest_url="$BASE_URL/api/version/latest"
        
        if command -v jq &> /dev/null; then
            VERSION=$(curl -fsSL "$latest_url" | jq -r '.version')
        else
            VERSION=$(curl -fsSL "$latest_url" | grep '"version":' | sed -E 's/.*"version": "([^\"]+)".*/\\1/')
        fi
        
        if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
            log_error "Failed to resolve latest version"
            exit 1
        fi
        
        log_verbose "Resolved latest version: $VERSION"
    fi
}

# Download binary
download_binary() {
    local artifact_slug="$1"
    local display_label="\${2:-$artifact_slug}"
    
    # Use proxy if available, otherwise direct GitHub
    local download_url
    if [ "$MIRROR_URL" = "$BASE_URL/releases/proxy" ]; then
        download_url="$MIRROR_URL/$VERSION/cert-ctrl-$artifact_slug.tar.gz"
    else
        download_url="$MIRROR_URL/{{GITHUB_REPO_OWNER}}/{{GITHUB_REPO_NAME}}/releases/download/$VERSION/cert-ctrl-$artifact_slug.tar.gz"
    fi

    LAST_DOWNLOAD_URL="$download_url"
    
    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: Would download cert-ctrl from $download_url"
        echo ""
        return 0
    fi

    local temp_file=$(mktemp)
    
    log_info "Downloading cert-ctrl $VERSION for $display_label..."
    log_verbose "Download URL: $download_url"
    
    if ! curl -fsSL "$download_url" -o "$temp_file"; then
        log_error "Failed to download cert-ctrl"
        rm -f "$temp_file"
        exit 1
    fi
    
    echo "$temp_file"
}

download_checksum() {
    local artifact_slug="$1"

    if [ "$DRY_RUN" = "true" ]; then
        LAST_CHECKSUM_URL=""
        return 0
    fi

    local checksum_url
    if [ "$MIRROR_URL" = "$BASE_URL/releases/proxy" ]; then
        checksum_url="$MIRROR_URL/$VERSION/cert-ctrl-$artifact_slug.tar.gz.sha256"
    else
        checksum_url="$MIRROR_URL/{{GITHUB_REPO_OWNER}}/{{GITHUB_REPO_NAME}}/releases/download/$VERSION/cert-ctrl-$artifact_slug.tar.gz.sha256"
    fi

    LAST_CHECKSUM_URL="$checksum_url"

    local checksum_file=$(mktemp)
    log_verbose "Fetching checksum from $checksum_url"

    if curl -fsSL "$checksum_url" -o "$checksum_file"; then
        echo "$checksum_file"
        return 0
    fi

    log_warning "Checksum file not available; skipping verification"
    rm -f "$checksum_file"
    echo ""
}

verify_checksum() {
    local archive_file="$1"
    local checksum_file="$2"

    if [ -z "$checksum_file" ]; then
        return 0
    fi

    if [ ! -f "$checksum_file" ]; then
        log_warning "Checksum file missing; skipping verification"
        return 0
    fi

    log_info "Verifying archive integrity..."

    local expected=$(awk 'NF>=1 {print $1; exit}' "$checksum_file")
    local actual_output=$("\${SHA256_CMD[@]}" "$archive_file")
    local actual=\${actual_output%% *}

    if [ -z "$expected" ]; then
        log_warning "Checksum file empty; skipping verification"
        return 0
    fi

    if [ "$expected" != "$actual" ]; then
        log_error "Checksum verification failed"
        log_verbose "Expected: $expected"
        log_verbose "Actual:   $actual"
        exit 1
    fi

    log_success "Checksum verified"
}

prompt_yes_no() {
    local message="$1"

    if [ "$NONINTERACTIVE" = "true" ]; then
        return 0
    fi

    read -p "$message [y/N]: " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        return 0
    fi
    return 1
}

install_config_files() {
    local extract_dir="$1"

    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: Would place configuration into $CONFIG_DIR"
        return 0
    fi

    local config_source=""
    if [ -d "$extract_dir/config" ]; then
        config_source="$extract_dir/config"
    elif [ -d "$extract_dir/etc/certctrl" ]; then
        config_source="$extract_dir/etc/certctrl"
    fi

    if [ -z "$config_source" ]; then
        log_verbose "No configuration directory found in archive"
        return 0
    fi

    log_info "Installing configuration to $CONFIG_DIR"
    if [ -d "$CONFIG_DIR" ] && [ -n "$(ls -A "$CONFIG_DIR" 2>/dev/null)" ] && [ "$FORCE" = "false" ]; then
        if [ "$NONINTERACTIVE" = "true" ]; then
            log_info "Configuration directory exists but continuing (non-interactive mode)"
        else
            log_warning "Configuration directory $CONFIG_DIR already exists and contains files"
            log_info "To overwrite: Use ?force=1 in URL or FORCE=true with sudo -E"
            log_info "Skipping configuration install"
            return 0
        fi
    fi
    mkdir -p "$CONFIG_DIR"
    cp -R "$config_source/." "$CONFIG_DIR/"
    log_success "Configuration installed"
}

ensure_service_account() {
    local account="$SERVICE_ACCOUNT"

    if [ "$account" = "" ] || [ "$account" = "root" ]; then
        return 0
    fi

    if id "$account" &> /dev/null; then
        return 0
    fi

    if command -v useradd &> /dev/null; then
        log_info "Creating service account $account"
        useradd --system --no-create-home --shell /usr/sbin/nologin "$account"
    else
        log_warning "useradd not available; please ensure account $account exists"
    fi
}

stop_service_if_running() {
    # Avoid ETXTBUSY when overwriting the binary while the service is running
    if [ "$EUID" -ne 0 ]; then
        return 0
    fi
    if [ "$SERVICE_MANAGER" = "openrc" ]; then
        local rc_service_bin=""
        if rc_service_bin=$(find_command_path rc-service 2>/dev/null); then
            local openrc_name
            openrc_name=$(get_openrc_service_name)
            if "$rc_service_bin" "$openrc_name" status >/dev/null 2>&1; then
                log_info "Stopping $openrc_name before upgrading binary"
                if "$rc_service_bin" "$openrc_name" stop >/dev/null 2>&1; then
                    RESTART_SERVICE_AFTER_INSTALL="true"
                else
                    log_warning "Failed to stop $openrc_name; continuing with installation"
                fi
            fi
        fi
        return 0
    fi
    if [ "$SERVICE_MANAGER" = "freebsd-rcd" ]; then
        local service_bin
        if service_bin=$(find_command_path service 2>/dev/null); then
            local rc_name
            rc_name=$(get_freebsd_service_name)
            if "$service_bin" "$rc_name" onestatus >/dev/null 2>&1; then
                log_info "Stopping $rc_name before upgrading binary"
                if "$service_bin" "$rc_name" stop >/dev/null 2>&1; then
                    RESTART_SERVICE_AFTER_INSTALL="true"
                else
                    log_warning "Failed to stop $rc_name; continuing with installation"
                fi
            fi
        fi
        return 0
    fi
    if ! command -v systemctl >/dev/null 2>&1; then
        return 0
    fi
    if ! systemctl list-unit-files "$SERVICE_NAME" >/dev/null 2>&1; then
        return 0
    fi
    if systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
        log_info "Stopping $SERVICE_NAME before upgrading binary"
        if systemctl stop "$SERVICE_NAME"; then
            RESTART_SERVICE_AFTER_INSTALL="true"
        else
            log_warning "Failed to stop $SERVICE_NAME; continuing with installation"
        fi
    fi
}

ensure_service_directories() {
    if [ ! -d "$CONFIG_DIR" ]; then
        log_info "Creating config directory $CONFIG_DIR"
        mkdir -p "$CONFIG_DIR"
    fi
    if [ ! -d "$STATE_DIR" ]; then
        log_info "Creating state directory $STATE_DIR"
        mkdir -p "$STATE_DIR"
    fi
    chown -R "$SERVICE_ACCOUNT:$SERVICE_ACCOUNT" "$CONFIG_DIR" 2>/dev/null || true
    chmod 755 "$CONFIG_DIR"
    chown -R "$SERVICE_ACCOUNT:$SERVICE_ACCOUNT" "$STATE_DIR" 2>/dev/null || true
    chmod 755 "$STATE_DIR"
}`,
String.raw`create_systemd_unit() {
    cat > "/etc/systemd/system/$SERVICE_NAME" << 'EOF'
[Unit]
Description=@@DESCRIPTION@@
After=network-online.target
Wants=network-online.target
StartLimitIntervalSec=0

[Service]
Type=simple
Restart=always
RestartSec=5
User=@@SERVICE_USER@@
Group=@@SERVICE_USER@@
WorkingDirectory=@@CONFIG_DIR@@
StateDirectory=@@STATE_DIR_NAME@@
ExecStart=@@BINARY_PATH@@ --config-dirs @@CONFIG_DIR@@ --keep-running
StandardOutput=journal
StandardError=journal
SyslogIdentifier=cert-ctrl

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=@@CONFIG_DIR@@
ReadWritePaths=@@STATE_DIR@@
@@ADDITIONAL_READWRITE_PATHS@@

[Install]
WantedBy=multi-user.target
EOF
}

create_openrc_service() {
    local openrc_name
    openrc_name=$(get_openrc_service_name)
    cat > "/etc/init.d/$openrc_name" << 'EOF'
#!/sbin/openrc-run

description="@@DESCRIPTION@@"
command="@@BINARY_PATH@@"
command_args="--config-dirs @@CONFIG_DIR@@ --keep-running"
command_user="@@SERVICE_USER@@"
command_background="yes"
directory="@@CONFIG_DIR@@"
pidfile="/run/@@OPENRC_NAME@@.pid"

depend() {
    need net
}

start_pre() {
    checkpath --directory --mode 0755 /run
}
EOF
}

enable_service_with_retry() {
    local attempt=1
    local max_attempts=2
    local last_output=""

    while [ $attempt -le $max_attempts ]; do
        if last_output=$(systemctl enable --now "$SERVICE_NAME" 2>&1); then
            log_success "Service $SERVICE_NAME started successfully"
            return 0
        fi

        local rc=$?

        if echo "$last_output" | grep -qi "does not exist" && [ $attempt -lt $max_attempts ]; then
            log_warning "systemctl enable reported missing unit (attempt $attempt). Forcing daemon-reload and retrying."
            systemctl daemon-reload
            sleep 1
        else
            log_warning "Service installation completed but failed to start"
            log_info "systemctl enable output: $last_output"
            log_info "Check logs with: journalctl -u $SERVICE_NAME"
            log_info "Start manually with: systemctl start $SERVICE_NAME"
            return $rc
        fi

        attempt=$((attempt + 1))
    done

    return 1
}

install_systemd_service_unit() {
    if ! command -v systemctl &> /dev/null; then
        log_warning "systemctl not available; skipping service installation"
        return 0
    fi

    local unit_path="/etc/systemd/system/$SERVICE_NAME"
    declare -a preserved_readwrite_paths=()
    declare -A seen_readwrite_paths=()
    if [ -f "$unit_path" ]; then
        while IFS= read -r line; do
            case "$line" in
                ReadWritePaths=*)
                    local existing_path="\${line#ReadWritePaths=}"
                    if [ -n "$existing_path" ] && [ "$existing_path" != "$CONFIG_DIR" ] && [ "$existing_path" != "$STATE_DIR" ]; then
                        if [ -z "\${seen_readwrite_paths[\$existing_path]:-}" ]; then
                            preserved_readwrite_paths+=("$existing_path")
                            seen_readwrite_paths["$existing_path"]=1
                        fi
                    fi
                    ;;
            esac
        done < "$unit_path"
        if [ \${#preserved_readwrite_paths[@]} -gt 0 ]; then
            log_verbose "Preserving existing ReadWritePaths entries: \${preserved_readwrite_paths[*]}"
        fi
    fi

    log_info "Installing systemd unit at /etc/systemd/system/$SERVICE_NAME"
    if [ -f "$unit_path" ] && [ "$FORCE" = "false" ]; then
        if [ "$NONINTERACTIVE" = "true" ]; then
            log_info "Overwriting existing service unit (non-interactive mode)"
        else
            log_warning "Service $SERVICE_NAME already exists."
            log_info "To overwrite: Use ?force=1 in URL or FORCE=true with sudo -E"
            log_info "Skipping service installation"
            return 0
        fi
    fi

    create_systemd_unit

    sed -i "s|@@BINARY_PATH@@|$INSTALL_DIR/cert-ctrl|g" "$unit_path"
    sed -i "s|@@CONFIG_DIR@@|$CONFIG_DIR|g" "$unit_path"
    sed -i "s|@@SERVICE_USER@@|$SERVICE_ACCOUNT|g" "$unit_path"
    sed -i "s|@@DESCRIPTION@@|$SERVICE_DESCRIPTION|g" "$unit_path"
    sed -i "s|@@STATE_DIR_NAME@@|$STATE_DIR_NAME|g" "$unit_path"
    sed -i "s|@@STATE_DIR@@|$STATE_DIR|g" "$unit_path"

    local extra_readwrite_block=""
    if [ \${#preserved_readwrite_paths[@]} -gt 0 ]; then
        extra_readwrite_block=$(printf 'ReadWritePaths=%s\n' "\${preserved_readwrite_paths[@]}")
    fi

    local tmp_unit=$(mktemp)
    if [ -z "$tmp_unit" ]; then
        log_error "Failed to allocate temporary file for unit rewrite"
        exit 1
    fi
    {
        while IFS= read -r line || [ -n "$line" ]; do
            if [ "$line" = "@@ADDITIONAL_READWRITE_PATHS@@" ]; then
                if [ -n "$extra_readwrite_block" ]; then
                    printf '%s\n' "$extra_readwrite_block"
                fi
                continue
            fi
            printf '%s\n' "$line"
        done < "$unit_path"
    } > "$tmp_unit"
    mv "$tmp_unit" "$unit_path"
    chmod 0644 "$unit_path"
    restore_selinux_context "$unit_path"

    ensure_service_directories

    systemctl daemon-reload
    if [ ! -f "$unit_path" ]; then
        log_error "Expected systemd unit $unit_path is missing after installation"
        exit 1
    fi
    log_success "Systemd unit installed successfully"

    if [ "$ENABLE_SERVICE" = "true" ]; then
        log_info "Enabling and starting $SERVICE_NAME"
        enable_service_with_retry
    else
        log_info "Service installed. Enable manually with: systemctl enable --now $SERVICE_NAME"
    fi
}

install_openrc_service_unit() {
    local openrc_name
    openrc_name=$(get_openrc_service_name)
    local init_path="/etc/init.d/$openrc_name"

    log_info "Installing OpenRC service at $init_path"
    if [ -f "$init_path" ] && [ "$FORCE" = "false" ]; then
        if [ "$NONINTERACTIVE" = "true" ]; then
            log_info "Overwriting existing OpenRC script (non-interactive mode)"
        else
            log_warning "Service $openrc_name already exists."
            log_info "To overwrite: Use ?force=1 in URL or FORCE=true with sudo -E"
            log_info "Skipping service installation"
            return 0
        fi
    fi

    create_openrc_service

    sed -i "s|@@BINARY_PATH@@|$INSTALL_DIR/cert-ctrl|g" "$init_path"
    sed -i "s|@@CONFIG_DIR@@|$CONFIG_DIR|g" "$init_path"
    sed -i "s|@@SERVICE_USER@@|$SERVICE_ACCOUNT|g" "$init_path"
    sed -i "s|@@DESCRIPTION@@|$SERVICE_DESCRIPTION|g" "$init_path"
    sed -i "s|@@OPENRC_NAME@@|$openrc_name|g" "$init_path"

    chmod 0755 "$init_path"

    ensure_service_directories

    log_success "OpenRC service installed successfully"

    if [ "$ENABLE_SERVICE" = "true" ]; then
        local rc_update_bin rc_service_bin
        if rc_update_bin=$(find_command_path rc-update 2>/dev/null); then
            if ! "$rc_update_bin" add "$openrc_name" default >/dev/null 2>&1; then
                log_warning "Failed to register $openrc_name with rc-update; run: rc-update add $openrc_name default"
            else
                log_info "Registered $openrc_name with rc-update (default runlevel)"
            fi
        else
            log_warning "rc-update not found; add service manually: rc-update add $openrc_name default"
        fi

        if rc_service_bin=$(find_command_path rc-service 2>/dev/null); then
            if "$rc_service_bin" "$openrc_name" restart >/dev/null 2>&1; then
                log_success "$openrc_name service started"
            else
                log_warning "Failed to start $openrc_name automatically; run: rc-service $openrc_name start"
            fi
        else
            log_warning "rc-service not found; start manually: rc-service $openrc_name start"
        fi
    else
        log_info "Service installed. Enable manually with: rc-update add $openrc_name default && rc-service $openrc_name start"
    fi
}

create_freebsd_rc_service() {
    local rc_name
    rc_name=$(get_freebsd_service_name)
    cat > "/usr/local/etc/rc.d/$rc_name" << 'EOF'
#!/bin/sh
# PROVIDE: @@RC_NAME@@
# REQUIRE: DAEMON NETWORKING
# KEYWORD: shutdown

. /etc/rc.subr

name="@@RC_NAME@@"
rcvar="\${name}_enable"

command="@@BINARY_PATH@@"
command_args="--config-dirs @@CONFIG_DIR@@ --keep-running"
pidfile="/var/run/\${name}.pid"
command_background="YES"

load_rc_config $name
: \${\${name}_enable:="NO"}

run_rc_command "$1"
EOF
}

install_freebsd_service_unit() {
    local rc_name
    rc_name=$(get_freebsd_service_name)
    local init_path="/usr/local/etc/rc.d/$rc_name"

    log_info "Installing FreeBSD rc.d service at $init_path"
    if [ -f "$init_path" ] && [ "$FORCE" = "false" ]; then
        if [ "$NONINTERACTIVE" = "true" ]; then
            log_info "Overwriting existing rc.d script (non-interactive mode)"
        else
            log_warning "Service $rc_name already exists."
            log_info "To overwrite: Use ?force=1 in URL or FORCE=true with sudo -E"
            log_info "Skipping service installation"
            return 0
        fi
    fi

    mkdir -p "/usr/local/etc/rc.d"
    create_freebsd_rc_service

    sed -i "s|@@BINARY_PATH@@|$INSTALL_DIR/cert-ctrl|g" "$init_path"
    sed -i "s|@@CONFIG_DIR@@|$CONFIG_DIR|g" "$init_path"
    sed -i "s|@@RC_NAME@@|$rc_name|g" "$init_path"

    chmod 0755 "$init_path"

    ensure_service_directories

    log_success "FreeBSD service installed successfully"

    if [ "$ENABLE_SERVICE" = "true" ]; then
        local sysrc_bin service_bin
        if sysrc_bin=$(find_command_path sysrc 2>/dev/null); then
            if ! "$sysrc_bin" "\${rc_name}_enable=YES" >/dev/null 2>&1; then
                log_warning "Failed to enable $rc_name via sysrc; set \${rc_name}_enable=YES manually"
            else
                log_info "Enabled $rc_name via sysrc"
            fi
        else
            log_warning "sysrc not found; enable manually: sysrc \${rc_name}_enable=YES"
        fi

        if service_bin=$(find_command_path service 2>/dev/null); then
            if "$service_bin" "$rc_name" restart >/dev/null 2>&1; then
                log_success "$rc_name service started"
            else
                log_warning "Failed to start $rc_name automatically; run: service $rc_name start"
            fi
        else
            log_warning "service command not found; start manually: service $rc_name start"
        fi
    else
        log_info "Service installed. Enable manually with: sysrc \${rc_name}_enable=YES && service $rc_name start"
    fi
}

install_service_unit() {
    if [ "$INSTALL_SERVICE" != "true" ]; then
        log_verbose "Service installation disabled"
        return 0
    fi

    if [ "$DRY_RUN" = "true" ]; then
        if [ "$SERVICE_MANAGER" = "openrc" ]; then
            log_info "DRY RUN: Would install OpenRC service $(get_openrc_service_name)"
        elif [ "$SERVICE_MANAGER" = "systemd" ]; then
            log_info "DRY RUN: Would install systemd unit $SERVICE_NAME"
        elif [ "$SERVICE_MANAGER" = "freebsd-rcd" ]; then
            log_info "DRY RUN: Would install FreeBSD rc.d service $(get_freebsd_service_name)"
        else
            log_info "DRY RUN: No supported service manager detected"
        fi
        return 0
    fi

    if [ "$EUID" -ne 0 ]; then
        log_warning "Service installation requires root privileges (skipping service setup)"
        if [ "$SERVICE_MANAGER" = "openrc" ]; then
            local openrc_name
            openrc_name=$(get_openrc_service_name)
            log_info "To install service manually after installation:"
            log_info "  sudo rc-update add $openrc_name default"
            log_info "  sudo rc-service $openrc_name start"
        elif [ "$SERVICE_MANAGER" = "freebsd-rcd" ]; then
            local rc_name
            rc_name=$(get_freebsd_service_name)
            log_info "To install service manually after installation:"
            log_info "  sudo sysrc \${rc_name}_enable=YES"
            log_info "  sudo service $rc_name start"
        else
            log_info "To install service manually after installation:"
            log_info "  sudo systemctl enable --now $SERVICE_NAME"
        fi
        return 0
    fi

    case "$SERVICE_MANAGER" in
        systemd)
            ensure_service_account
            install_systemd_service_unit
            ;;
        openrc)
            ensure_service_account
            install_openrc_service_unit
            ;;
        freebsd-rcd)
            ensure_service_account
            install_freebsd_service_unit
            ;;
        *)
            log_warning "No supported service manager detected; skipping service installation"
            ;;
    esac
}

# Install binary
install_binary() {
    local temp_file="$1"
    local platform_arch="$2"
    
    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: Would install to $INSTALL_DIR"
        if [ "$INSTALL_SERVICE" = "true" ]; then
            if [ "$SERVICE_MANAGER" = "openrc" ]; then
                log_info "DRY RUN: Would install OpenRC service $(get_openrc_service_name)"
            elif [ "$SERVICE_MANAGER" = "systemd" ]; then
                log_info "DRY RUN: Would install systemd unit $SERVICE_NAME"
            elif [ "$SERVICE_MANAGER" = "freebsd-rcd" ]; then
                log_info "DRY RUN: Would install FreeBSD rc.d service $(get_freebsd_service_name)"
            else
                log_info "DRY RUN: Service installation skipped (no supported manager)"
            fi
        fi
        return 0
    fi
    
    mkdir -p "$INSTALL_DIR"
    
    log_info "Installing to $INSTALL_DIR..."
    
    # Extract
    local extract_dir=$(mktemp -d)
    if ! tar -xzf "$temp_file" -C "$extract_dir"; then
        log_error "Failed to extract downloaded file"
        rm -rf "$extract_dir"
        exit 1
    fi
    
    # Find binary
    local binary_path=""
    if [ -f "$extract_dir/cert-ctrl" ]; then
        binary_path="$extract_dir/cert-ctrl"
    elif [ -f "$extract_dir/bin/cert-ctrl" ]; then
        binary_path="$extract_dir/bin/cert-ctrl"
    else
        log_error "cert-ctrl binary not found in archive"
        rm -rf "$extract_dir"
        exit 1
    fi
    
    # Check existing installation
    if [ -f "$INSTALL_DIR/cert-ctrl" ] && [ "$FORCE" = "false" ]; then
        local current_version=""
        if [ -x "$INSTALL_DIR/cert-ctrl" ]; then
            current_version=$("$INSTALL_DIR/cert-ctrl" --version 2>/dev/null || echo "unknown")
        fi
        
        log_warning "cert-ctrl is already installed at $INSTALL_DIR/cert-ctrl"
        if [ -n "$current_version" ]; then
            log_info "Current version: $current_version"
            log_info "New version: $VERSION"
        fi
        log_info ""
        log_info "To proceed with installation, choose one of:"
    log_info "  1. URL parameter:   curl -fsSL \"$BASE_URL/install.sh?force=1\" | sudo bash"
    log_info "  2. Environment var: FORCE=true curl -fsSL \"$BASE_URL/install.sh\" | sudo -E bash"
    log_info "  3. Remove existing: sudo rm $INSTALL_DIR/cert-ctrl && curl -fsSL \"$BASE_URL/install.sh\" | sudo bash"
        log_info ""
        log_error "Installation stopped. Use one of the options above to continue."
        rm -rf "$extract_dir"
        exit 1
    fi
    
    # Install
    stop_service_if_running
    chmod +x "$binary_path"
    cp "$binary_path" "$INSTALL_DIR/cert-ctrl"
    log_success "Binary installed"

    install_config_files "$extract_dir"
    install_service_unit
    apply_distro_specific_fixes

    if [ "$RESTART_SERVICE_AFTER_INSTALL" = "true" ]; then
        if [ "$SERVICE_MANAGER" = "openrc" ]; then
            local rc_service_bin=""
            if rc_service_bin=$(find_command_path rc-service 2>/dev/null); then
                local openrc_name
                openrc_name=$(get_openrc_service_name)
                if "$rc_service_bin" "$openrc_name" start >/dev/null 2>&1; then
                    log_success "Service $openrc_name restarted"
                else
                    log_warning "Failed to restart $openrc_name; start manually with: rc-service $openrc_name start"
                fi
            else
                log_warning "Service was stopped but rc-service is unavailable; start manually once rc-service is installed"
            fi
        elif [ "$SERVICE_MANAGER" = "freebsd-rcd" ]; then
            local service_bin
            if service_bin=$(find_command_path service 2>/dev/null); then
                local rc_name
                rc_name=$(get_freebsd_service_name)
                if "$service_bin" "$rc_name" start >/dev/null 2>&1; then
                    log_success "Service $rc_name restarted"
                else
                    log_warning "Failed to restart $rc_name; start manually with: service $rc_name start"
                fi
            else
                log_warning "Service was stopped but 'service' is unavailable; start manually once available"
            fi
        else
            if [ "$EUID" -ne 0 ] || ! command -v systemctl >/dev/null 2>&1; then
                log_warning "Service $SERVICE_NAME was stopped but could not be restarted automatically"
            else
                log_info "Restarting $SERVICE_NAME after upgrade"
                if systemctl start "$SERVICE_NAME"; then
                    log_success "Service $SERVICE_NAME restarted"
                else
                    log_warning "Failed to restart $SERVICE_NAME; start manually with: systemctl start $SERVICE_NAME"
                fi
            fi
        fi
    fi

    rm -rf "$extract_dir"

    log_success "cert-ctrl installed successfully!"
}

# Setup PATH
setup_path() {
    # System installation - /usr/local/bin should already be in PATH
    return 0
}

# Verify installation
verify_installation() {
    local binary_path="$INSTALL_DIR/cert-ctrl"
    
    if [ ! -f "$binary_path" ]; then
        log_error "Installation failed: binary not found"
        exit 1
    fi
    
    if "$binary_path" --version &>/dev/null; then
        local version=$("$binary_path" --version 2>/dev/null | head -n1)
        log_success "Installation verified! Version: $version"
        return 0
    else
        log_warning "Binary installed but version check failed"
        
        # Try to run the binary and show error output
        echo ""
        log_info "Trying to diagnose the issue..."
        local error_output
        error_output=$("$binary_path" 2>&1 || true)
        
        # Check if it's a glibc version issue
        if echo "$error_output" | grep -q "GLIBC_"; then
            log_error "Your system is missing required glibc versions!"
            echo ""
            
            # Show current glibc version
            local current_glibc=""
            if [ -f /lib/x86_64-linux-gnu/libc.so.6 ]; then
                current_glibc=$(/lib/x86_64-linux-gnu/libc.so.6 2>&1 | grep -o "release version [0-9]*\.[0-9]*" | awk '{print $NF}')
            fi
            
            if [ -z "$current_glibc" ] && command -v ldd &>/dev/null; then
                current_glibc=$(ldd --version 2>&1 | head -1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            fi
            
            if [ -n "$current_glibc" ]; then
                log_warning "Your system has: glibc $current_glibc"
            else
                log_warning "Unable to detect your current glibc version"
            fi
            
            # Extract and show required versions
            local required_versions
            required_versions=$(echo "$error_output" | grep -o "GLIBC_[0-9.]*" | sort -u | tr '\n' ' ')
            log_warning "Required versions: $required_versions"
            
            echo ""
            
            # Detect OS and provide specific advice
            if [ -f /etc/os-release ]; then
                local os_id=$(grep "^ID=" /etc/os-release | cut -d'=' -f2 | tr -d '"')
                local version_id=$(grep "^VERSION_ID=" /etc/os-release | cut -d'=' -f2 | tr -d '"')
                
                log_info "Your system: $os_id $version_id"
                echo ""
                
                case "$os_id" in
                    ubuntu)
                        case "$version_id" in
                            "24.04"|"23.10"|"23.04")
                                log_success "Ubuntu $version_id has compatible glibc - update your packages:"
                                echo "  sudo apt update && sudo apt full-upgrade -y"
                                ;;
                            "22.04"|"20.04")
                                log_error "Ubuntu $version_id is not supported - glibc is too old."
                                echo ""
                                log_warning "cert-ctrl requires glibc 2.36+ but Ubuntu $version_id only has glibc 2.35."
                                echo ""
                                log_info "ONLY SOLUTION: Upgrade to Ubuntu 24.04 LTS"
                                echo "  sudo do-release-upgrade"
                                echo ""
                                log_info "Alternative: Use Docker instead"
                                echo "  docker run -it cert-ctrl --version"
                                ;;
                            *)
                                log_info "Try updating your Ubuntu packages:"
                                echo "  sudo apt update && sudo apt full-upgrade -y"
                                ;;
                        esac
                        ;;
                    debian)
                        log_info "For Debian $version_id, try:"
                        echo "  sudo apt update && sudo apt full-upgrade -y"
                        ;;
                    rhel|centos|rocky|almalinux|fedora)
                        log_info "For RHEL/CentOS/Rocky/Fedora, update packages:"
                        echo "  sudo dnf update -y"
                        ;;
                    *)
                        log_info "Try updating your system packages:"
                        echo "  sudo apt update && sudo apt upgrade -y  # Debian-based"
                        echo "  sudo dnf update -y                    # RHEL-based"
                        ;;
                esac
            fi
            
            echo ""
            log_info "Alternative options:"
            echo "  1. Use Docker: docker run cert-ctrl --version"
            echo "  2. Build from source on your system"
            echo "  3. Use a container with compatible glibc"
        else
            log_error "Binary failed to run:"
            echo "$error_output"
        fi

        if is_suse_like && echo "$error_output" | grep -qi "digital envelope routines"; then
            log_warning "Detected OpenSSL compatibility issue on $OS_NAME"
            log_info "Install compatibility libs and re-run: sudo zypper install -y libopenssl1_1 libopenssl1_1-hmac"
            log_info "If the problem persists, rebuild cert-ctrl against the SUSE OpenSSL toolchain."
        fi
        
        echo ""
        log_error "Installation incomplete due to runtime dependencies."
        return 1
    fi
}`,
String.raw`# Main function
main() {
    log_info "Starting cert-ctrl installation..."
    log_verbose "Service URL: $BASE_URL"
    log_verbose "Mirror: $MIRROR_URL"
    log_verbose "Install directory: $INSTALL_DIR"
    log_verbose "Config directory: $CONFIG_DIR"
    log_verbose "Service install: $INSTALL_SERVICE (enable=$ENABLE_SERVICE)"
    
    detect_os_release

    SERVICE_MANAGER=$(detect_service_manager)
    if [ -z "$SERVICE_MANAGER" ]; then
        SERVICE_MANAGER="none"
    fi
    log_verbose "Service manager: $SERVICE_MANAGER"

    check_dependencies
    
    local platform_arch=$(detect_platform)
    local artifact_slug=$(select_artifact_slug "$platform_arch")
    log_verbose "Platform: $platform_arch"
    if [ "$artifact_slug" != "$platform_arch" ]; then
        log_verbose "Using artifact variant: $artifact_slug"
    fi
    
    resolve_version
    
    if [ ! -w "$(dirname "$INSTALL_DIR")" ] && [ "$EUID" -ne 0 ]; then
        log_error "Installation requires root privileges"
        exit 1
    fi

    maybe_skip_install
    
    local temp_file=$(download_binary "$artifact_slug" "$platform_arch")

    if [ "$DRY_RUN" = "true" ]; then
        log_info "DRY RUN: No changes were made"
        return 0
    fi

    if [ -z "$temp_file" ]; then
        log_error "Download failed"
        exit 1
    fi

    local checksum_file=$(download_checksum "$artifact_slug")
    verify_checksum "$temp_file" "$checksum_file"
    
    install_binary "$temp_file" "$platform_arch"
    
    rm -f "$temp_file"
    if [ -n "$checksum_file" ]; then
        rm -f "$checksum_file"
    fi
    
    setup_path
    verify_installation
    
    echo
    log_success "cert-ctrl installation completed!"
    echo
    echo "Next steps:"
    echo "  - Run: cert-ctrl --help"
    if [ "$INSTALL_SERVICE" = "true" ]; then
        if [ "$SERVICE_MANAGER" = "openrc" ]; then
            local openrc_name
            openrc_name=$(get_openrc_service_name)
            if [ "$ENABLE_SERVICE" = "true" ]; then
                echo "  - Check service status: rc-service $openrc_name status"
            else
                echo "  - Enable service when ready: sudo rc-update add $openrc_name default && sudo rc-service $openrc_name start"
            fi
        elif [ "$SERVICE_MANAGER" = "freebsd-rcd" ]; then
            local rc_name
            rc_name=$(get_freebsd_service_name)
            if [ "$ENABLE_SERVICE" = "true" ]; then
                echo "  - Check service status: service $rc_name status"
            else
                echo "  - Enable service when ready: sudo sysrc \${rc_name}_enable=YES && sudo service $rc_name start"
            fi
        elif [ "$ENABLE_SERVICE" = "true" ]; then
            echo "  - Check service status: systemctl status $SERVICE_NAME"
        else
            echo "  - Enable service when ready: sudo systemctl enable --now $SERVICE_NAME"
        fi
    fi
    echo
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --version)
            VERSION="$2"
            shift 2
            ;;
        --install-dir|--dir)
            INSTALL_DIR="$2"
            shift 2
            ;;
        --config-dir)
            CONFIG_DIR="$2"
            shift 2
            ;;
        --service)
            INSTALL_SERVICE="true"
            ENABLE_SERVICE="true"
            shift
            ;;
        --no-service)
            INSTALL_SERVICE="false"
            ENABLE_SERVICE="false"
            shift
            ;;
        --enable-service)
            ENABLE_SERVICE="true"
            shift
            ;;
        --no-enable)
            ENABLE_SERVICE="false"
            shift
            ;;
        --non-interactive|--yes|-y)
            NONINTERACTIVE="true"
            FORCE=true
            shift
            ;;
        --channel)
            CHANNEL="$2"
            shift 2
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --verbose|-v)
            VERBOSE=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help|-h)
            echo "cert-ctrl installation script"
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  --user-install    Install to user directory"
            echo "  --version VER     Install specific version"
            echo "  --install-dir DIR Custom install directory"
            echo "  --config-dir DIR  Override configuration directory"
            echo "  --force           Overwrite existing installation"
            echo "  --service         Install and enable systemd service"
            echo "  --no-service      Skip systemd service installation"
            echo "  --enable-service  Enable service after install"
            echo "  --no-enable       Install service but do not enable"
            echo "  --non-interactive Run without prompts (assumes yes)"
            echo "  --verbose         Enable verbose output"
            echo "  --dry-run         Show what would be done"
            echo "  --help            Show this help"
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            exit 1
            ;;
    esac
done

if [ -z "$CONFIG_DIR" ]; then
    CONFIG_DIR="/etc/certctrl"
fi

if [ -z "$INSTALL_SERVICE" ]; then
    INSTALL_SERVICE="true"
fi

if [ -z "$ENABLE_SERVICE" ]; then
    ENABLE_SERVICE="$INSTALL_SERVICE"
fi

if [ -z "$FORCE" ]; then
    FORCE="false"
fi

if [ -z "$DRY_RUN" ]; then
    DRY_RUN="false"
fi

if [ -z "$VERBOSE" ]; then
    VERBOSE="false"
fi

# Run installation
main`
];

export const bashTemplate = bashTemplateSections.join('\n');
