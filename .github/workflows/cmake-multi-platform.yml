name: CMake on multiple platforms

on:
  # Manual trigger from GitHub UI with optional inputs
  workflow_dispatch:
    inputs:
      build_type:
        description: CMake build type (Release-Compat builds for broader compatibility - uses static linking on Linux, static runtime on Windows)
        type: choice
        options:
          - Release
          - Release-Compat
          - Debug
        default: Release
      target_runner:
        description: Select where to run the workflow
        type: choice
        options:
          - github-all
          - github-ubuntu-latest
          - github-windows-latest
          - github-macos-latest
          - self-host-linux
          - self-host-windows
          - self-host-macos
          - self-host-all
          - self-host-custom
        default: github-all
      self_host_labels:
        description: Space-separated labels for the self-hosted runner (e.g. "self-hosted Linux X64")
        type: string
        default: self-hosted Linux X64
      clean_build:
        description: Remove existing build directory on self-hosted runner before configuring
        type: choice
        options:
          - 'false'
          - 'true'
        default: 'true'
      skip_tests:
        description: Skip running ctest after the build
        type: choice
        options:
          - 'false'
          - 'true'
        default: 'true'
      upload_artifacts:
        description: Upload compiled build directory as a workflow artifact
        type: choice
        options:
          - 'false'
          - 'true'
        default: 'true'
      # Builds still run from the workflow's checked-out ref; when true, Publish GitHub release uses the latest v* tag if present.
      do_release:
            description: Publish a GitHub release using the latest v* tag
            type: choice
            options:
              - 'false'
              - 'true'
            default: 'false'
  # push:
  #   tags:
  #     - 'v*'

# Cancel previous in-flight runs for the same ref to save time
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}${{ github.event_name == 'workflow_dispatch' && format('-manual-{0}', github.run_id) || '' }}
  cancel-in-progress: ${{ github.event_name != 'workflow_dispatch' }}

permissions:
  contents: write

jobs:
  set-matrix:
    name: Prepare matrix
    runs-on: ubuntu-latest
    outputs:
      os-list: ${{ steps.set.outputs.os-list }}
      enable-openssl3: ${{ steps.set.outputs.enable-openssl3 }}
      variant-list: ${{ steps.set.outputs.variant-list }}
    steps:
      - id: set
        shell: bash
        env:
          SELF_HOST_LABELS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.self_host_labels || 'self-hosted Linux X64' }}
        run: |
          enable_openssl3=false
          os_list='[]'
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            target="${{ github.event.inputs.target_runner || 'github-all' }}"
            case "$target" in
              self-host-linux)
                os_list='[]'
                enable_openssl3=false
                ;;
              self-host-windows)
                os_list='[["self-hosted","Windows","X64"]]'
                enable_openssl3=false
                ;;
              self-host-macos)
                os_list='[["self-hosted","macOS","X64"]]'
                enable_openssl3=false
                ;;
              self-host-all)
                os_list='[["self-hosted","Windows","X64"],["self-hosted","macOS","X64"]]'
                enable_openssl3=false
                ;;
              self-host-custom)
                labels="$SELF_HOST_LABELS"
                labels="${labels//,/ }"
                json_labels=""
                for token in $labels; do
                  trimmed=$(printf '%s' "$token" | xargs)
                  if [ -n "$trimmed" ]; then
                    if [ -n "$json_labels" ]; then
                      json_labels="$json_labels,\"$trimmed\""
                    else
                      json_labels="\"$trimmed\""
                    fi
                  fi
                done
                if [ -z "$json_labels" ]; then
                  json_labels="\"self-hosted\""
                fi
                os_list="[[${json_labels}]]"
                enable_openssl3=false
                ;;
              github-ubuntu-latest)
                os_list='["ubuntu-22.04"]'
                enable_openssl3=true
                ;;
              github-windows-latest)
                os_list='["windows-2022"]'
                enable_openssl3=false
                ;;
              github-macos-latest)
                os_list='["macos-12"]'
                enable_openssl3=false
                ;;
              github-all|*)
                os_list='["ubuntu-22.04","windows-2022","macos-12"]'
                enable_openssl3=true
                ;;
            esac
          else
            os_list='["ubuntu-22.04","windows-2022","macos-12"]'
            enable_openssl3=true
          fi

          echo "os-list=$os_list" >> "$GITHUB_OUTPUT"
          echo "enable-openssl3=$enable_openssl3" >> "$GITHUB_OUTPUT"

          if [ "$enable_openssl3" = "true" ]; then
            echo 'variant-list=["default","openssl3"]' >> "$GITHUB_OUTPUT"
          else
            echo 'variant-list=["default"]' >> "$GITHUB_OUTPUT"
          fi

  build:
    needs: set-matrix
    runs-on: ${{ matrix.os }}
    env:
      # Enable vcpkg's GitHub Actions cache provider for fast binary caching
      VCPKG_BINARY_SOURCES: 'clear;x-gha,readwrite'
      VCPKG_FEATURE_FLAGS: manifests,binarycaching,registries
      REQUESTED_BUILD_TYPE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.build_type || 'Release' }}
      REQUESTED_SKIP_TESTS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.skip_tests || 'false' }}
      REQUESTED_UPLOAD_ARTIFACTS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.upload_artifacts || 'true' }}
      REQUESTED_CLEAN_BUILD: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.clean_build || 'false' }}
      IS_SELF_HOSTED: ${{ github.event_name == 'workflow_dispatch' && startsWith(github.event.inputs.target_runner || 'github-all', 'self-host-') }}
      SKIP_CONFIGURE: 'false'
      BUILD_DIR: build
      ARTIFACT_PLATFORM: ''
      ARTIFACT_ARCH: ''
      ARTIFACT_SLUG: unknown
      ARTIFACT_BASE: cert-ctrl-unknown
      ARCHIVE_EXT: tar.gz
      BUILD_VARIANT: ${{ matrix.variant }}

    strategy:
      fail-fast: false
      matrix:
        os: ${{ fromJSON(needs.set-matrix.outputs.os-list) }}
        build_type:
          - ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.build_type || 'Release' }}
        variant: ${{ fromJSON(needs.set-matrix.outputs.variant-list) }}

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
          fetch-tags: true

      - name: Determine artifact metadata (Unix)
        if: runner.os != 'Windows'
        run: |
          set -euo pipefail
          os_slug=$(printf '%s' "${RUNNER_OS:-linux}" | tr '[:upper:]' '[:lower:]')
          case "$os_slug" in
            macos|darwin)
              os_slug="macos"
              ;;
            linux)
              os_slug="linux"
              ;;
            *)
              os_slug="linux"
              ;;
          esac

          arch=$(uname -m)
          case "$arch" in
            x86_64|amd64)
              arch_slug="x64"
              ;;
            arm64|aarch64)
              arch_slug="arm64"
              ;;
            armv7*|armhf)
              arch_slug="arm"
              ;;
            *)
              arch_slug="x64"
              ;;
          esac

          # Use unified naming for all build types
          artifact_slug="${os_slug}-${arch_slug}"
          artifact_base="cert-ctrl-${os_slug}-${arch_slug}"

          variant="${{ matrix.variant }}"
          if [ -n "$variant" ] && [ "$variant" != "default" ]; then
            artifact_slug="${artifact_slug}-${variant}"
            artifact_base="${artifact_base}-${variant}"
          fi

          {
            echo "ARTIFACT_PLATFORM=$os_slug"
            echo "ARTIFACT_ARCH=$arch_slug"
            echo "ARTIFACT_SLUG=$artifact_slug"
            echo "ARTIFACT_BASE=$artifact_base"
            echo "ARCHIVE_EXT=tar.gz"
          } >> "$GITHUB_ENV"

      - name: Determine artifact metadata (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $osSlug = 'windows'
          switch -regex ($env:PROCESSOR_ARCHITECTURE) {
            'ARM64' { $archSlug = 'arm64'; break }
            'ARM' { $archSlug = 'arm'; break }
            default { $archSlug = 'x64' }
          }
          
          # Use unified naming for all build types
          $artifactSlug = "$osSlug-$archSlug"
          $artifactBase = "cert-ctrl-$osSlug-$archSlug"

          $variant = "${{ matrix.variant }}"
          if (-not [string]::IsNullOrWhiteSpace($variant) -and $variant -ne 'default') {
            $artifactSlug = "$artifactSlug-$variant"
            $artifactBase = "$artifactBase-$variant"
          }
          
          "ARTIFACT_PLATFORM=$osSlug" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "ARTIFACT_ARCH=$archSlug" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "ARTIFACT_SLUG=$artifactSlug" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "ARTIFACT_BASE=$artifactBase" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "ARCHIVE_EXT=zip" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Detect reusable configure (self-hosted Unix)
        if: env.IS_SELF_HOSTED == 'true' && runner.os != 'Windows' && env.REQUESTED_CLEAN_BUILD != 'true'
        shell: bash
        run: |
          set -euo pipefail
          cache_file="${{ github.workspace }}/build/CMakeCache.txt"
          requested="${{ matrix.build_type }}"
          if [ -f "$cache_file" ]; then
            cached=$(awk -F= '/^CMAKE_BUILD_TYPE:STRING=/{print $2}' "$cache_file" || true)
            if [ "$cached" = "$requested" ]; then
              echo "Reusing existing CMake configuration for $requested"
              echo "SKIP_CONFIGURE=true" >> "$GITHUB_ENV"
              exit 0
            fi
          fi
          echo "SKIP_CONFIGURE=false" >> "$GITHUB_ENV"

      - name: Detect reusable configure (self-hosted Windows)
        if: env.IS_SELF_HOSTED == 'true' && runner.os == 'Windows' && env.REQUESTED_CLEAN_BUILD != 'true'
        shell: pwsh
        run: |
          $cache = Join-Path "${{ github.workspace }}" 'build/CMakeCache.txt'
          $requested = "${{ matrix.build_type }}"
          if (Test-Path $cache) {
            $match = Select-String -Path $cache -Pattern '^CMAKE_BUILD_TYPE:STRING=(.*)$'
            if ($match) {
              $cached = $match.Matches[0].Groups[1].Value
              if ($cached -eq $requested) {
                Write-Host "Reusing existing CMake configuration for $requested"
                "SKIP_CONFIGURE=true" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
                exit 0
              }
            }
          }
          "SKIP_CONFIGURE=false" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Prepare vcpkg binary cache (self-hosted Unix)
        if: env.IS_SELF_HOSTED == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          os_slug=$(printf '%s' "${RUNNER_OS:-self-hosted}" | tr '[:upper:]' '[:lower:]')
          arch_slug=$(printf '%s' "${RUNNER_ARCH:-x64}" | tr '[:upper:]' '[:lower:]')
          slug="${os_slug}-${arch_slug}"
          workspace_root="${RUNNER_WORKSPACE:-${GITHUB_WORKSPACE}}"
          if [ -z "$workspace_root" ]; then
            echo "RUNNER_WORKSPACE is not defined" >&2
            exit 1
          fi
          base_root=$(dirname "$(dirname "$(cd "$workspace_root" && pwd)")")
          cache_root="${base_root}/_vcpkg-cache/${slug}"
          mkdir -p "$cache_root/downloads"
          echo "Using vcpkg cache directory: $cache_root"
          {
            echo "VCPKG_BINARY_SOURCES=clear;files,$cache_root,readwrite"
            echo "VCPKG_DEFAULT_BINARY_CACHE=$cache_root"
            echo "VCPKG_DOWNLOADS=$cache_root/downloads"
          } >> "$GITHUB_ENV"

      - name: Prepare vcpkg binary cache (self-hosted Windows)
        if: env.IS_SELF_HOSTED == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $workspaceRoot = $env:RUNNER_WORKSPACE
          if (-not $workspaceRoot) { $workspaceRoot = $env:GITHUB_WORKSPACE }
          if (-not $workspaceRoot) { throw 'RUNNER_WORKSPACE is not defined' }
          $workspaceRoot = [System.IO.Path]::GetFullPath($workspaceRoot)
          $parent = [System.IO.Directory]::GetParent($workspaceRoot)
          if (-not $parent) { throw 'Unable to determine parent of RUNNER_WORKSPACE' }
          $grandParent = [System.IO.Directory]::GetParent($parent.FullName)
          if (-not $grandParent) { throw 'Unable to determine grandparent of RUNNER_WORKSPACE' }
          $cacheRootBase = Join-Path $grandParent.FullName '_vcpkg-cache'
          $osSlug = $env:RUNNER_OS
          if ([string]::IsNullOrWhiteSpace($osSlug)) { $osSlug = 'self-hosted' }
          $archSlug = $env:RUNNER_ARCH
          if ([string]::IsNullOrWhiteSpace($archSlug)) { $archSlug = 'x64' }
          $slug = "{0}-{1}" -f $osSlug.ToLowerInvariant(), $archSlug.ToLowerInvariant()
          $cacheRoot = Join-Path $cacheRootBase $slug
          $downloads = Join-Path $cacheRoot 'downloads'
          New-Item -ItemType Directory -Force -Path $cacheRoot | Out-Null
          New-Item -ItemType Directory -Force -Path $downloads | Out-Null
          Write-Host "Using vcpkg cache directory: $cacheRoot"
          "VCPKG_BINARY_SOURCES=clear;files,$cacheRoot,readwrite" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "VCPKG_DEFAULT_BINARY_CACHE=$cacheRoot" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "VCPKG_DOWNLOADS=$downloads" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Reusing CMake configure cache
        if: env.SKIP_CONFIGURE == 'true'
        run: echo "Skipping CMake configure step; existing cache is compatible with requested build type."

      - name: Clean build directory (self-hosted Unix)
        if: env.IS_SELF_HOSTED == 'true' && env.REQUESTED_CLEAN_BUILD == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          echo "Removing existing build artifacts from self-hosted runner (Unix)"
          rm -rf "${{ github.workspace }}/build"
          rm -f "${{ github.workspace }}/compile_commands.json"

      - name: Clean build directory (self-hosted Windows)
        if: env.IS_SELF_HOSTED == 'true' && env.REQUESTED_CLEAN_BUILD == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Removing existing build artifacts from self-hosted runner (Windows)"
          $buildPath = Join-Path "${{ github.workspace }}" 'build'
          if (Test-Path $buildPath) {
            Remove-Item -Path $buildPath -Recurse -Force -ErrorAction SilentlyContinue
          }
          $compileCommands = Join-Path "${{ github.workspace }}" 'compile_commands.json'
          if (Test-Path $compileCommands) {
            Remove-Item -Path $compileCommands -Force -ErrorAction SilentlyContinue
          }

      - name: Cache vcpkg downloads
        if: env.IS_SELF_HOSTED != 'true'
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/external/vcpkg/downloads
          key: vcpkg-downloads-${{ runner.os }}-${{ hashFiles('vcpkg.json', 'vcpkg-configuration.json') }}
          restore-keys: |
            vcpkg-downloads-${{ runner.os }}-

      # Prepare MSVC environment on Windows runners
      - name: Setup MSVC (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      - name: Setup Ninja
        if: env.IS_SELF_HOSTED != 'true'
        uses: seanmiddleditch/gha-setup-ninja@v4

      # Extra guard: ensure Ninja is installed per-OS (fallback if action fails)
      - name: Ensure Ninja on macOS
        if: runner.os == 'macOS' && env.IS_SELF_HOSTED != 'true'
        run: |
          brew update
          # Install Ninja and required autotools for libsodium
          brew install ninja autoconf automake libtool pkg-config libomp

      - name: Ensure Ninja on macOS (self-hosted)
        if: runner.os == 'macOS' && env.IS_SELF_HOSTED == 'true'
        run: |
          if ! command -v ninja >/dev/null 2>&1; then
            brew update
            brew install ninja autoconf automake libtool pkg-config libomp
          else
            echo "Ninja already available; skipping brew install"
          fi

      - name: Ensure Ninja on Ubuntu
        if: runner.os == 'Linux' && env.IS_SELF_HOSTED != 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build libomp-dev libssl-dev

      - name: Ensure Ninja on Windows
        if: runner.os == 'Windows' && env.IS_SELF_HOSTED != 'true'
        run: choco install ninja --no-progress -y

      # Use vcpkg manifest mode via the repository submodule on all platforms
      - name: Setup sccache
        if: env.IS_SELF_HOSTED != 'true'
        uses: mozilla-actions/sccache-action@v0.0.3

      - name: Set build directory environment variable (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          build_type="${{ github.event.inputs.build_type || matrix.build_type }}"
          variant="${{ matrix.variant }}"
          if [ "$variant" = "openssl3" ]; then
            echo "BUILD_DIR=${{ github.workspace }}/build/openssl3-dynamic" >> "$GITHUB_ENV"
            exit 0
          fi
          if [ "$build_type" = "Release-Compat" ] && [ "${{ runner.os }}" = "Linux" ]; then
            echo "BUILD_DIR=${{ github.workspace }}/build/release-compat" >> "$GITHUB_ENV"
          else
            echo "BUILD_DIR=${{ github.workspace }}/build" >> "$GITHUB_ENV"
          fi

      - name: Set build directory environment variable (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $build_type = "${{ github.event.inputs.build_type || matrix.build_type }}"
          $variant = "${{ matrix.variant }}"
          if ($variant -eq 'openssl3') {
            echo "BUILD_DIR=${{ github.workspace }}/build/openssl3-dynamic" >> $env:GITHUB_ENV
            return
          }
          if ($build_type -eq "Release-Compat") {
            echo "BUILD_DIR=${{ github.workspace }}/build/release-compat" >> $env:GITHUB_ENV
          } else {
            echo "BUILD_DIR=${{ github.workspace }}/build" >> $env:GITHUB_ENV
          }


      - name: Configure CMake (Unix)
        if: runner.os != 'Windows' && env.SKIP_CONFIGURE != 'true'
        shell: bash
        run: |
          set -eu
          build_type="${{ github.event.inputs.build_type || matrix.build_type }}"
          variant="${{ matrix.variant }}"

          if [ "$variant" = "openssl3" ]; then
            cmake --preset=openssl3-dynamic
            exit 0
          fi

          if [ "$build_type" = "Release-Compat" ] && [ "${{ runner.os }}" = "Linux" ]; then
            cmake --preset=release-compat \
              -D CMAKE_C_COMPILER=clang \
              -D CMAKE_CXX_COMPILER=clang++
            exit 0
          fi

          if [ "$build_type" = "Release-Compat" ] && [ "${{ runner.os }}" = "macOS" ]; then
            set -- \
              -G "Ninja" \
              -B "${{ github.workspace }}/build" \
              -S "${{ github.workspace }}" \
              -DCMAKE_C_COMPILER=clang \
              -DCMAKE_CXX_COMPILER=clang++ \
              -DCMAKE_BUILD_TYPE=Release \
              -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}/external/vcpkg/scripts/buildsystems/vcpkg.cmake" \
              -DVCPKG_TARGET_TRIPLET=x64-osx \
              -DCMAKE_CXX_FLAGS="-O2 -DNDEBUG" \
              -DCMAKE_C_FLAGS="-O2 -DNDEBUG" \
              -DDISABLE_LTO=ON
          else
            set -- \
              -G "Ninja" \
              -B "${{ github.workspace }}/build" \
              -S "${{ github.workspace }}" \
              -DCMAKE_C_COMPILER=clang \
              -DCMAKE_CXX_COMPILER=clang++ \
              -DCMAKE_BUILD_TYPE="${build_type}" \
              -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}/external/vcpkg/scripts/buildsystems/vcpkg.cmake"
          fi

          if [ "${{ env.IS_SELF_HOSTED }}" != "true" ] && [ "$build_type" != "Release-Compat" ]; then
            set -- "$@" \
              -DCMAKE_C_COMPILER_LAUNCHER=sccache \
              -DCMAKE_CXX_COMPILER_LAUNCHER=sccache
          fi

          cmake "$@"


      - name: Configure CMake (Windows)
        if: runner.os == 'Windows' && env.SKIP_CONFIGURE != 'true'
        shell: pwsh
        run: |
          $buildType = "${{ github.event.inputs.build_type || matrix.build_type }}"
          
          # For Windows, Release-Compat is treated as Release with static runtime
          if ($buildType -eq "Release-Compat") {
            $effectiveBuildType = "Release"
            $buildDir = "${{ github.workspace }}/build/release-compat"
            $cmakeArgs = @(
              '-G', 'Ninja',
              '-B', $buildDir,
              '-S', "${{ github.workspace }}",
              '-DCMAKE_C_COMPILER=cl.exe',
              '-DCMAKE_CXX_COMPILER=cl.exe',
              "-DCMAKE_BUILD_TYPE=$effectiveBuildType",
              "-DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/external/vcpkg/scripts/buildsystems/vcpkg.cmake",
              '-DVCPKG_TARGET_TRIPLET=x64-windows-static',
              # Ensure MSVC builds in workflow accept C++20 features (designated initializers etc.)
              "-DCMAKE_CXX_STANDARD=20"
            )
            $cmakeArgs += '-DFORCE_CLEAN_GIT_DESCRIBE=ON'
          } else {
            # Use manual configuration for other build types
            $buildDir = "${{ github.workspace }}/build"
            $cmakeArgs = @(
              '-G', 'Ninja',
              '-B', $buildDir,
              '-S', "${{ github.workspace }}",
              '-DCMAKE_C_COMPILER=cl.exe',
              '-DCMAKE_CXX_COMPILER=cl.exe',
              "-DCMAKE_BUILD_TYPE=$buildType",
              "-DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/external/vcpkg/scripts/buildsystems/vcpkg.cmake",
              # Windows (MSVC) sometimes needs an explicit standard override to enable
              # C++20 language features used in test/util headers (designated initializers).
              "-DCMAKE_CXX_STANDARD=20"
            )
            $cmakeArgs += '-DFORCE_CLEAN_GIT_DESCRIBE=ON'
          }
          
          if ("${{ env.IS_SELF_HOSTED }}" -ne "true") {
            if ($buildType -ne "Release-Compat") {
              $cmakeArgs += @(
                '-DCMAKE_C_COMPILER_LAUNCHER=sccache',
                '-DCMAKE_CXX_COMPILER_LAUNCHER=sccache'
              )
            }
          }
          cmake @cmakeArgs

      - name: Build (Unix)
        if: runner.os != 'Windows'
        run: |
          build_type="${{ github.event.inputs.build_type || matrix.build_type }}"
          variant="${{ matrix.variant }}"
          if [ "$variant" = "openssl3" ]; then
            cmake --build --preset=openssl3-dynamic --parallel
            exit 0
          fi
          if [ "$build_type" = "Release-Compat" ] && [ "${{ runner.os }}" = "Linux" ]; then
            # Use build preset for Linux compatibility builds
            cmake --build --preset=release-compat --parallel
          else
            # Use regular build for all other cases (including macOS compat)
            cmake --build "${{ env.BUILD_DIR }}" --config ${{ matrix.build_type }} --parallel
          fi

      - name: Build (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $buildType = "${{ github.event.inputs.build_type || matrix.build_type }}"
          $buildDir = "${{ env.BUILD_DIR }}"
          if (-not (Test-Path $buildDir)) {
            throw "CMake build directory not found: $buildDir"
          }

          if ($buildType -eq "Release-Compat") {
            # Release-Compat configures as Release but lives under the compat build directory
            cmake --build $buildDir --config Release --parallel
          } else {
            cmake --build $buildDir --config ${{ matrix.build_type }} --parallel
          }

      - name: Test
        if: env.REQUESTED_SKIP_TESTS != 'true'
        working-directory: ${{ env.BUILD_DIR }}
        run: ctest --build-config ${{ matrix.build_type }}

      - name: Install build outputs
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true'
        run: >
          cmake --install "${{ env.BUILD_DIR }}"
          --config ${{ matrix.build_type }}
          --prefix "${{ github.workspace }}/install"

      - name: Normalize executable name (Unix)
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true' && runner.os != 'Windows'
        run: |
          set -euo pipefail
          INSTALL_DIR="${{ github.workspace }}/install/bin"
          if [ ! -d "$INSTALL_DIR" ]; then
            exit 0
          fi
          if [ -f "$INSTALL_DIR/cert-ctrl" ]; then
            exit 0
          fi
          if [ -f "$INSTALL_DIR/cert_ctrl" ]; then
            mv "$INSTALL_DIR/cert_ctrl" "$INSTALL_DIR/cert-ctrl"
          elif [ -f "$INSTALL_DIR/certctrl" ]; then
            mv "$INSTALL_DIR/certctrl" "$INSTALL_DIR/cert-ctrl"
          fi

      - name: Normalize executable name (Windows)
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $installBin = Join-Path "${{ github.workspace }}" 'install\bin'
          if (-not (Test-Path $installBin)) { return }
          $target = Join-Path $installBin 'cert-ctrl.exe'
          if (Test-Path $target) { return }
          foreach ($candidate in @('cert_ctrl.exe','certctrl.exe')) {
            $source = Join-Path $installBin $candidate
            if (Test-Path $source) {
              Move-Item -Path $source -Destination $target -Force
              break
            }
          }

      - name: Package installer payload (Unix)
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true' && runner.os != 'Windows'
        run: |
          set -euo pipefail
          INSTALL_DIR="${{ github.workspace }}/install"
          BUILD_DIR="${{ github.workspace }}/build"
          PAYLOAD_DIR="${{ github.workspace }}/package"
          rm -rf "$PAYLOAD_DIR"
          mkdir -p "$PAYLOAD_DIR"
          if [ ! -d "$INSTALL_DIR/bin" ]; then
            echo "ERROR: Expected executable directory '$INSTALL_DIR/bin' missing" >&2
            exit 1
          fi
          if [ ! -f "$INSTALL_DIR/bin/cert-ctrl" ] && [ ! -f "$INSTALL_DIR/bin/cert-ctrl.exe" ]; then
            echo "ERROR: cert-ctrl executable not found in '$INSTALL_DIR/bin'" >&2
            exit 1
          fi
          mkdir -p "$PAYLOAD_DIR/bin"
          cp -a "$INSTALL_DIR/bin"/. "$PAYLOAD_DIR/bin"/
          DEST_DIR="${{ github.workspace }}/dist"
          mkdir -p "$DEST_DIR"
          ARCHIVE_NAME="${ARTIFACT_BASE:-cert-ctrl-unknown}.${ARCHIVE_EXT:-tar.gz}"
          tar -C "$PAYLOAD_DIR" -czf "$DEST_DIR/$ARCHIVE_NAME" .

      - name: Generate checksum (Unix)
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true' && runner.os != 'Windows'
        run: |
          set -euo pipefail
          DEST_DIR="${{ github.workspace }}/dist"
          ARCHIVE_NAME="${ARTIFACT_BASE:-cert-ctrl-unknown}.${ARCHIVE_EXT:-tar.gz}"
          cd "$DEST_DIR"
          if command -v sha256sum >/dev/null 2>&1; then
            sha_cmd=(sha256sum)
          else
            sha_cmd=(shasum -a 256)
          fi
          "${sha_cmd[@]}" "$ARCHIVE_NAME" | tee "$ARCHIVE_NAME.sha256"

      - name: Package installer payload (Windows)
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $install = Join-Path $env:GITHUB_WORKSPACE 'install'
          $payload = Join-Path $env:GITHUB_WORKSPACE 'package'
          if (Test-Path $payload) { Remove-Item $payload -Recurse -Force }
          New-Item -Path $payload -ItemType Directory -Force | Out-Null

          $candidateDirs = @()
          $primaryBin = Join-Path $install 'bin'
          if (Test-Path $primaryBin) { $candidateDirs += $primaryBin }
          $fallbackBins = Get-ChildItem -Path $install -Directory -Recurse -Depth 2 -ErrorAction SilentlyContinue | Where-Object { $_.Name -match '^(bin|Release|Debug)$' }
          foreach ($dir in $fallbackBins) {
            if ($candidateDirs -notcontains $dir.FullName) {
              $candidateDirs += $dir.FullName
            }
          }

          if (-not $candidateDirs) {
            Write-Error "No candidate directories found under '$install' for staging executables."
            exit 1
          }

          $binSrc = $null
          $executables = @()
          foreach ($dir in $candidateDirs) {
            $found = Get-ChildItem -Path $dir -Filter *.exe -File -Recurse -ErrorAction SilentlyContinue
            if ($found) {
              $binSrc = $dir
              $executables = $found
              break
            }
          }

          if (-not $binSrc -or -not $executables) {
            Write-Error "No executables (*.exe) found under '$install'." 
            Get-ChildItem -Path $install -Recurse | Select-Object FullName
            exit 1
          }

          Write-Host "Staging executables from '$binSrc': $($executables.Name -join ', ')"

          $binDst = Join-Path $payload 'bin'
          Write-Host "Staging destination (binDst): $binDst"
          foreach ($exe in $executables) {
            $relative = $exe.FullName.Substring($binSrc.Length)
            while ($relative.StartsWith('\') -or $relative.StartsWith('/')) {
              $relative = $relative.Substring(1)
            }
            $destPath = Join-Path $binDst $relative
            $destDir = Split-Path -Path $destPath -Parent
            if ($destDir -and -not (Test-Path $destDir)) {
              New-Item -Path $destDir -ItemType Directory -Force | Out-Null
            }
            Copy-Item -Path $exe.FullName -Destination $destPath -Force
          }

          $stagedExecutables = Get-ChildItem -Path $binDst -Filter *.exe -File -Recurse -ErrorAction SilentlyContinue
          if (-not $stagedExecutables) {
            Write-Error "Expected staged executables in '$binDst' but none were found."
            exit 1
          }

          $dest = Join-Path $env:GITHUB_WORKSPACE 'dist'
          Write-Host "Archive output directory (dest): $dest"
          New-Item -Path $dest -ItemType Directory -Force | Out-Null

          $archiveBase = $env:ARTIFACT_BASE
          if ([string]::IsNullOrWhiteSpace($archiveBase)) { $archiveBase = 'cert-ctrl-unknown' }
          $archiveExt = $env:ARCHIVE_EXT
          if ([string]::IsNullOrWhiteSpace($archiveExt)) { $archiveExt = 'zip' }

          $archive = "{0}.{1}" -f $archiveBase, $archiveExt
          Write-Host "Archive filename (archive): $archive"
          $archivePath = Join-Path $dest $archive
          if (Test-Path $archivePath) { Remove-Item $archivePath -Force }

          $itemsToArchive = Get-ChildItem -Path $payload -Recurse -File
          if (-not $itemsToArchive) {
            Write-Error "No files staged in '$payload'; cannot create archive."
            Get-ChildItem -Path $payload -Recurse | Select-Object FullName
            exit 1
          }

          $payloadWildcard = Join-Path $payload '*'
          Write-Host "Creating archive '$archive' from:"
          $itemsToArchive | ForEach-Object { Write-Host "  - $($_.FullName)" }

          Compress-Archive -Path $payloadWildcard -DestinationPath $archivePath -Force -CompressionLevel Optimal

          if (-not (Test-Path $archivePath)) {
            Write-Error "Archive was not created at '$archivePath'."
            Get-ChildItem -Path $dest -Force | Select-Object FullName, Length
            exit 1
          }

          Write-Host "Created archive '$archivePath' (size: $((Get-Item $archivePath).Length) bytes)"

      - name: Generate checksum (Windows)
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $dest = Join-Path $env:GITHUB_WORKSPACE 'dist'
          $archiveBase = $env:ARTIFACT_BASE
          if ([string]::IsNullOrWhiteSpace($archiveBase)) { $archiveBase = 'cert-ctrl-unknown' }
          $archiveExt = $env:ARCHIVE_EXT
          if ([string]::IsNullOrWhiteSpace($archiveExt)) { $archiveExt = 'zip' }
          $archive = "{0}.{1}" -f $archiveBase, $archiveExt
          $archivePath = Join-Path $dest $archive
          if (-not (Test-Path $archivePath)) {
            Write-Error "Archive not found at '$archivePath'"
            exit 1
          }
          $hash = Get-FileHash -LiteralPath $archivePath -Algorithm SHA256
          $checksumFile = "{0}.sha256" -f $archivePath
          $line = "{0}  {1}" -f $hash.Hash.ToLowerInvariant(), $archive
          Set-Content -Path $checksumFile -Value $line

      - name: Upload installer artifact (Unix)
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true' && runner.os != 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: installer-${{ env.ARTIFACT_SLUG }}
          path: |
            ${{ github.workspace }}/dist/${{ env.ARTIFACT_BASE }}.${{ env.ARCHIVE_EXT }}
            ${{ github.workspace }}/dist/${{ env.ARTIFACT_BASE }}.${{ env.ARCHIVE_EXT }}.sha256
          if-no-files-found: error

      - name: Upload installer artifact (Windows)
        if: env.REQUESTED_UPLOAD_ARTIFACTS == 'true' && runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: installer-${{ env.ARTIFACT_SLUG }}
          path: |
            ${{ github.workspace }}/dist/${{ env.ARTIFACT_BASE }}.${{ env.ARCHIVE_EXT }}
            ${{ github.workspace }}/dist/${{ env.ARTIFACT_BASE }}.${{ env.ARCHIVE_EXT }}.sha256
          if-no-files-found: error

      - name: Upload vcpkg logs (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: vcpkg-logs-${{ runner.os }}
          path: |
            ${{ env.BUILD_DIR }}/vcpkg-manifest-install.log
            ${{ env.BUILD_DIR }}/vcpkg_installed/*/buildtrees/**/*.log
            ${{ env.BUILD_DIR }}/vcpkg_installed/*/buildtrees/**/*.txt
          if-no-files-found: ignore

  self-host-linux:
    name: Self-hosted Linux builds
    if: >-
      github.event_name != 'workflow_dispatch' ||
      startsWith(github.event.inputs.target_runner || '', 'self-host-') && (
        github.event.inputs.target_runner == 'self-host-linux' ||
        github.event.inputs.target_runner == 'self-host-all'
      )
    needs: set-matrix
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: ubuntu-release
            runner: [self-hosted, Linux, X64]
            build_target: ubuntu-docker
            build_script: scripts/build-ubuntu-docker.sh
            build_preset: release
            build_dir: build/release
            install_prefix: install/linux-x64
            artifact_name: selfhost-ubuntu-docker
            artifact_slug: linux-x64
            artifact_base: cert-ctrl-linux-x64
            archive_ext: tar.gz
          - name: ubuntu-openssl3
            runner: [self-hosted, Linux, X64]
            build_target: ubuntu-openssl3-docker
            build_script: scripts/build-ubuntu-docker.sh
            build_preset: openssl3-dynamic
            build_dir: build/openssl3-dynamic
            install_prefix: install/linux-x64-openssl3
            artifact_name: selfhost-ubuntu-openssl3
            artifact_slug: linux-x64-openssl3
            artifact_base: cert-ctrl-linux-x64-openssl3
            archive_ext: tar.gz
          - name: alpine-release
            runner: [self-hosted, Linux, X64, docker]
            build_target: alpine-docker
            build_script: scripts/build-alpine-docker.sh
            build_preset: ""
            build_dir: build/alpine-release
            install_prefix: install/linux-musl-x64
            artifact_name: selfhost-alpine-release
            artifact_slug: linux-musl-x64
            artifact_base: cert-ctrl-linux-musl-x64
            archive_ext: tar.gz
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
          fetch-tags: true
      - name: Verify Docker availability
        run: docker info

      - name: Build self-hosted target
        env:
          DOCKER_BUILDKIT: '0'
          BUILD_DIR_REL: ${{ matrix.build_dir }}
          INSTALL_PREFIX_REL: ${{ matrix.install_prefix }}
        run: |
          set -euo pipefail
          script="./${{ matrix.build_script }}"
          preset="${{ matrix.build_preset }}"
          if [ -n "$preset" ]; then
            bash "$script" "$preset"
          else
            bash "$script"
          fi

      - name: Normalize executable name (self-hosted)
        run: |
          set -euo pipefail
          INSTALL_DIR="${{ github.workspace }}/${{ matrix.install_prefix }}/bin"
          if [ ! -d "$INSTALL_DIR" ]; then
            exit 0
          fi
          if [ -f "$INSTALL_DIR/cert-ctrl" ]; then
            exit 0
          fi
          if [ -f "$INSTALL_DIR/cert_ctrl" ]; then
            mv "$INSTALL_DIR/cert_ctrl" "$INSTALL_DIR/cert-ctrl"
          elif [ -f "$INSTALL_DIR/certctrl" ]; then
            mv "$INSTALL_DIR/certctrl" "$INSTALL_DIR/cert-ctrl"
          fi

      - name: Package installer payload (self-hosted)
        run: |
          set -euo pipefail
          INSTALL_DIR="${{ github.workspace }}/${{ matrix.install_prefix }}"
          PAYLOAD_DIR="${{ github.workspace }}/package/${{ matrix.name }}"
          DEST_DIR="${{ github.workspace }}/dist"
          ARCHIVE_BASE="${{ matrix.artifact_base }}"
          ARCHIVE_EXT="${{ matrix.archive_ext }}"
          rm -rf "$PAYLOAD_DIR"
          mkdir -p "$PAYLOAD_DIR"
          if [ ! -d "$INSTALL_DIR/bin" ]; then
            echo "ERROR: Expected executable directory '$INSTALL_DIR/bin' missing" >&2
            exit 1
          fi
          if [ ! -f "$INSTALL_DIR/bin/cert-ctrl" ] && [ ! -f "$INSTALL_DIR/bin/cert-ctrl.exe" ]; then
            echo "ERROR: cert-ctrl executable not found in '$INSTALL_DIR/bin'" >&2
            exit 1
          fi
          mkdir -p "$PAYLOAD_DIR/bin"
          cp -a "$INSTALL_DIR/bin"/. "$PAYLOAD_DIR/bin"/
          mkdir -p "$DEST_DIR"
          ARCHIVE_NAME="$ARCHIVE_BASE.$ARCHIVE_EXT"
          tar -C "$PAYLOAD_DIR" -czf "$DEST_DIR/$ARCHIVE_NAME" .

      - name: Generate checksum (self-hosted)
        run: |
          set -euo pipefail
          DEST_DIR="${{ github.workspace }}/dist"
          ARCHIVE_BASE="${{ matrix.artifact_base }}"
          ARCHIVE_EXT="${{ matrix.archive_ext }}"
          ARCHIVE_NAME="$ARCHIVE_BASE.$ARCHIVE_EXT"
          cd "$DEST_DIR"
          if command -v sha256sum >/dev/null 2>&1; then
            sha_cmd=(sha256sum)
          else
            sha_cmd=(shasum -a 256)
          fi
          "${sha_cmd[@]}" "$ARCHIVE_NAME" | tee "$ARCHIVE_NAME.sha256"

      - name: Upload self-hosted artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: |
            ${{ github.workspace }}/dist/${{ matrix.artifact_base }}.${{ matrix.archive_ext }}
            ${{ github.workspace }}/dist/${{ matrix.artifact_base }}.${{ matrix.archive_ext }}.sha256
          if-no-files-found: error

  publish-release:
    needs:
      - build
      - self-host-linux
    if: >-
      (
        github.event_name == 'workflow_dispatch' &&
        github.event.inputs.upload_artifacts == 'true' &&
        github.event.inputs.do_release == 'true'
      ) || (
        github.event_name == 'push' &&
        startsWith(github.ref, 'refs/tags/v')
      )
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine release tag
        id: release
        shell: bash
        run: |
          set -euo pipefail

          tag=""
          title=""

          if [ "${GITHUB_EVENT_NAME}" = "push" ] && [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            tag="${GITHUB_REF#refs/tags/}"
            title="$tag"
          else
            if describe=$(git describe --tags --long --dirty --match "v[0-9]*.[0-9]*.[0-9]*" --exclude "*-*" --abbrev=8 2>/dev/null); then
              describe=${describe%-dirty}
              tag="$describe"
              title="$describe"
            else
              short_sha=$(git rev-parse --short HEAD)
              tag="build-${GITHUB_RUN_ID}-${short_sha}"
              title="$tag"
            fi
          fi

          sanitize_value() {
            python3 -c "import re, sys; value=sys.argv[1]; value=re.sub(r'-0-g[0-9a-f]+(?=-|$)', '', value); value=value.rstrip('-'); sys.stdout.write(value)" "$1"
          }

          tag=$(sanitize_value "$tag")
          title=$(sanitize_value "$title")

          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "title=$title" >> "$GITHUB_OUTPUT"

      - name: Download installer artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets
          merge-multiple: true

      - name: Publish GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
          RELEASE_TAG: ${{ steps.release.outputs.tag }}
          RELEASE_TITLE: ${{ steps.release.outputs.title }}
        shell: bash
        run: |
          set -euo pipefail

          mapfile -t asset_files < <(find release-assets -type f -print | sort)
          if [ ${#asset_files[@]} -eq 0 ]; then
            echo "No artifacts were downloaded; cannot publish release" >&2
            exit 1
          fi

          if git rev-parse "$RELEASE_TAG^{commit}" >/dev/null 2>&1; then
            notes_args=(--notes-from-tag)
          else
            notes_args=(--notes "Automated release from workflow run ${GITHUB_RUN_ID}")
          fi

          if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            echo "Release $RELEASE_TAG already exists; uploading assets"
            gh release upload "$RELEASE_TAG" "${asset_files[@]}" --clobber
            gh release edit "$RELEASE_TAG" --title "$RELEASE_TITLE" >/dev/null
          else
            echo "Creating release $RELEASE_TAG"
            gh release create "$RELEASE_TAG" "${asset_files[@]}" --title "$RELEASE_TITLE" "${notes_args[@]}"
          fi

          {
            echo "## Release $RELEASE_TAG"
            printf '* %s\n' "${asset_files[@]}"
          } >> "$GITHUB_STEP_SUMMARY"

